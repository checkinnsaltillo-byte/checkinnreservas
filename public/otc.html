<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Checkinnreservas · Dashboard OTC</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --panel:#0f1a30; --text:#e8eefc; --muted:#9fb0d0; --line:#1e2b4a;
      --shadow: 0 12px 28px rgba(0,0,0,.35);
      --r:16px; --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--font);
      background:linear-gradient(180deg,#070b15 0%, #0b1220 40%, #070b15 100%);
      color:var(--text);
    }
    header{
      position:sticky; top:0; z-index:60;
      background:rgba(7,11,21,.75); backdrop-filter: blur(10px);
      border-bottom:1px solid var(--line);
    }
    .wrap{max-width:1280px; margin:0 auto; padding:16px 18px;}
    .topbar{display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap}
    .brand{display:flex; align-items:center; gap:10px;}
    .logo{
      width:36px; height:36px; border-radius:12px;
      background: radial-gradient(circle at 30% 30%, #4cc9f0 0%, #4361ee 55%, #3a0ca3 100%);
      box-shadow: 0 10px 20px rgba(67,97,238,.35);
    }
    h1{font-size:16px; margin:0; font-weight:800; letter-spacing:.2px}
    .sub{margin:2px 0 0; color:var(--muted); font-size:12px}
    .actions{display:flex; align-items:center; gap:10px; flex-wrap:wrap}
    button, select, input{
      background:var(--panel); color:var(--text);
      border:1px solid var(--line); border-radius:12px; padding:10px 12px;
      font-size:13px; outline:none;
    }
    button{cursor:pointer}
    button:hover{border-color:#2b3c63}
    button.primary{
      background:linear-gradient(180deg, rgba(76,201,240,.18), rgba(67,97,238,.10));
      border-color:rgba(76,201,240,.35);
    }
    button.ghost{background:transparent}
    .status{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; border-radius:999px;
      background:rgba(11,18,32,.65); border:1px solid var(--line);
      font-size:12px; color:var(--muted);
    }
    .dot{width:8px; height:8px; border-radius:999px; background:#64748b}
    .dot.ok{background:#4ade80}
    .dot.err{background:#fb7185}
    .dot.busy{background:#fbbf24}

    .card{
      background:linear-gradient(180deg, rgba(15,26,48,.98), rgba(11,18,32,.98));
      border:1px solid var(--line);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      overflow:hidden;
      margin-top:14px;
    }
    .hd{
      padding:14px 14px 10px; border-bottom:1px solid var(--line);
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .hd h2{margin:0; font-size:14px; letter-spacing:.2px}
    .hint{margin:3px 0 0; font-size:12px; color:var(--muted)}
    .bd{padding:14px}

    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:end}
    .row > *{flex:1}
    .row .small{flex:.9}
    .row .xsmall{flex:.75}

    .pill{
      display:inline-flex; align-items:center; gap:6px;
      padding:4px 8px; border-radius:999px;
      background:rgba(76,201,240,.10);
      border:1px solid rgba(76,201,240,.22);
      color:var(--text);
      font-size:12px;
      white-space:nowrap;
    }

    .kpis{
      display:grid; gap:10px;
      grid-template-columns: repeat(6, 1fr);
    }
    @media (max-width: 1100px){ .kpis{grid-template-columns:repeat(3,1fr)} }
    @media (max-width: 720px){ .kpis{grid-template-columns:repeat(2,1fr)} }
    @media (max-width: 520px){ .kpis{grid-template-columns:1fr} }

    .kpi{
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(18,31,58,.7), rgba(15,26,48,.55));
      border-radius:16px;
      padding:12px;
      min-height: 88px;
    }
    .kpi .lbl{font-size:12px; color:var(--muted)}
    .kpi .val{margin-top:6px; font-size:18px; font-weight:900; letter-spacing:.3px}
    .kpi .meta{margin-top:6px; font-size:12px; color:var(--muted)}
    .kpi .mini{margin-top:8px; height:110px; width:100%}

    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;}

    .tableWrap{
      border:1px solid var(--line);
      border-radius:14px;
      overflow:hidden;
      background:rgba(18,31,58,.35);
    }
    table{width:100%; border-collapse:collapse; font-size:12.5px}
    thead{
      position:sticky; top:0;
      background:rgba(11,18,32,.95);
      z-index:5;
    }
    th, td{
      padding:10px 10px;
      border-bottom:1px solid rgba(30,43,74,.75);
      vertical-align:top;
      text-align:left;
      white-space:nowrap;
    }
    tbody tr:hover{background:rgba(76,201,240,.06)}
    .scrollY{max-height: 560px; overflow:auto;}
    .footer{padding:14px 18px; color:var(--muted); font-size:12px; border-top:1px solid var(--line);}

    /* ======= OCUPACIÓN: tabla sticky header + sticky first col ======= */
    .occScroll{ max-height: 520px; overflow: auto; }
    #occTable{
      width:100%;
      border-collapse: separate;
      border-spacing: 0;
      font-size:12.5px;
    }
    #occTable th, #occTable td{
      padding:10px 10px;
      border-bottom:1px solid rgba(30,43,74,.75);
      white-space: nowrap;
    }
    #occTable thead th{
      position: sticky; top: 0; z-index: 7;
      background: rgba(11,18,32,.98);
      border-bottom: 1px solid rgba(30,43,74,.75);
    }
    #occTable .houseCol{
      position: sticky; left: 0; z-index: 6;
      background: rgba(11,18,32,.98);
      border-right: 1px solid rgba(30,43,74,.75);
      font-weight: 800;
    }
    #occTable thead th.houseCol{ z-index: 10; }

    .occCell{ min-width: 210px; white-space: normal; line-height: 1.25; }
    .occTop{ display:flex; justify-content:space-between; gap:10px; font-size:12px; color:var(--muted); }
    .occMain{ margin-top:6px; display:flex; align-items:center; gap:10px; }
    .bar{
      flex:1; height:10px; border-radius:999px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .bar > div{
      height:100%;
      width:0%;
      background:linear-gradient(90deg, rgba(76,201,240,.9), rgba(67,97,238,.9));
    }
    #occLineWrap{ overflow:hidden; }

    /* ======= Multi-combobox (dropdown con checks) ======= */
    .mcb{
      position:relative;
      min-width: 220px;
    }
    .mcbBtn{
      width:100%;
      text-align:left;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .mcbBtn span{
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      color: var(--text);
    }
    .mcbBtn .caret{
      opacity:.8;
      font-size:12px;
      margin-left:8px;
    }
    .mcbPanel{
      position:absolute;
      top: calc(100% + 8px);
      left: 0;
      right: 0;
      z-index: 80;
      background: rgba(11,18,32,.98);
      border:1px solid var(--line);
      border-radius:14px;
      box-shadow: var(--shadow);
      padding:10px;
      display:none;
    }
    .mcb.open .mcbPanel{ display:block; }
    .mcbSearch{
      width:100%;
      margin-bottom:10px;
      padding:10px 12px;
      border-radius:12px;
    }
    .mcbTools{
      display:flex;
      gap:8px;
      margin-bottom:10px;
      flex-wrap:wrap;
    }
    .mcbTools button{
      padding:8px 10px;
      border-radius:12px;
      font-size:12px;
    }
    .mcbList{
      max-height: 240px;
      overflow:auto;
      border:1px solid rgba(30,43,74,.75);
      border-radius:12px;
      background: rgba(18,31,58,.25);
    }
    .mcbItem{
      display:flex;
      gap:10px;
      align-items:flex-start;
      padding:9px 10px;
      border-bottom:1px solid rgba(30,43,74,.55);
    }
    .mcbItem:last-child{ border-bottom:none; }
    .mcbItem:hover{ background: rgba(76,201,240,.06); }
    .mcbItem label{
      display:flex;
      gap:10px;
      align-items:flex-start;
      width:100%;
      cursor:pointer;
      white-space:normal;
      line-height:1.2;
      font-size:12.5px;
    }
    .mcbItem input{ margin-top:2px; }
    .mcbFooter{
      margin-top:10px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      color:var(--muted);
      font-size:12px;
    }
  
  /* Sortable headers */
  th.sortable{ cursor:pointer; user-select:none; position:relative; }
  th.sortable::after{ content:""; opacity:.55; margin-left:6px; }
  th.sortable[data-dir="asc"]::after{ content:"▲"; }
  th.sortable[data-dir="desc"]::after{ content:"▼"; }

  /* ⭐ importante */
  .vipStar{ display:inline-flex; align-items:center; gap:6px; }
  .vipStar .s{ color:#ffd36a; filter: drop-shadow(0 1px 2px rgba(0,0,0,.25)); }

  /* Fix: allow dropdown panels to overflow in Parámetros card only */
  #mcbPropiedad{ position:relative; }
  #mcbPropiedad .mcbPanel{ z-index: 9999; }
  section.card:has(#mcbPropiedad){ overflow: visible !important; }

</style>
</head>

<body>
<header>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <h1>Checkinnreservas · Dashboard OTC</h1>
          <div class="sub">Backend: Cloud Run · <span class="mono" id="baseUrl">same-origin</span></div>
        </div>
      </div>

      <div class="actions">
        <span id="apiStatus" class="status"><span class="dot busy"></span><span>Listo</span></span>
        <!-- Cargar ya no es necesario, lo dejamos como "Recargar" por si quieres forzar fetch -->
        <button id="btnReload" class="primary">Recargar datos</button>
        <button id="btnCsv">Descargar CSV</button>
        <button id="btnDebug" class="ghost">Debug</button>
      </div>
    </div>
  </div>
</header>

<main class="wrap">

  <!-- Parámetros -->
  <section class="card">
    <div class="hd">
      <div>
        <h2>Parámetros</h2>
        <div class="hint">
          API: <span class="mono">/api/otc</span> y <span class="mono">/api/otc.csv</span> · Fechas incluyen overlap.
          Los filtros aplican al instante.
        </div>
      </div>
      <div class="hint" id="metaLine">—</div>
    </div>

    <div class="bd">
      <div class="row">
        <label style="flex:1">
          <div class="hint">Desde</div>
          <input id="from" type="date" />
        </label>
        <label style="flex:1">
          <div class="hint">Hasta</div>
          <input id="to" type="date" />
        </label>

        <label class="small">
          <div class="hint">Buscar</div>
          <input id="q" placeholder="Guest / House / Id / Source / LineItem..." />
        </label>

        <!-- ✅ combobox multi: Propiedad -->
        <div class="mcb" id="mcbPropiedad" style="flex:1.2">
          <div class="hint">Propiedad</div>
          <button class="mcbBtn" type="button">
            <span class="mcbLabel">Todas</span>
            <span class="caret">▾</span>
          </button>
          <div class="mcbPanel">
            <input class="mcbSearch" type="text" placeholder="Buscar propiedad..." />
            <div class="mcbTools">
              <button type="button" class="mcbAll">Seleccionar todo</button>
              <button type="button" class="mcbNone">Limpiar</button>
            </div>
            <div class="mcbList"></div>
            <div class="mcbFooter">
              <span class="mcbCount">0 seleccionados</span>
              <button type="button" class="mcbClose">Cerrar</button>
            </div>
          </div>
        </div>

        <label class="xsmall">
          <div class="hint">Source</div>
          <select id="selSource">
            <option value="">Todos</option>
          </select>
        </label>

        <label class="xsmall">
          <div class="hint">Status</div>
          <select id="selStatus">
            <option value="">Todos</option>
          </select>
        </label>
      </div>

      <div class="hint" style="margin-top:10px">
        Tip: “Propiedad” es multiselección con checks. Si no seleccionas nada, se asume “todas”.
      </div>
    </div>
  </section>

  <!-- KPIs + mini charts por monto -->
  <section class="card">
    <div class="hd">
      <div>
        <h2>KPIs</h2>
        <div class="hint">Montos por LineItem + gráficas por <b>monto</b> (sum GrossAmount). Incluye etiquetas en barras.</div>
      </div>
      <div class="hint"><span class="pill" id="pillFiltered">0 filas</span></div>
    </div>

    <div class="bd">
      <div class="kpis">
        <div class="kpi">
          <div class="lbl">Reservas únicas</div>
          <div class="val" id="kpiBookings">—</div>
          <div class="meta">IDs distintos</div>
        </div>

        <div class="kpi">
          <div class="lbl">Noches (sum)</div>
          <div class="val" id="kpiNights">—</div>
          <div class="meta">Suma Nights</div>
        </div>

        <div class="kpi">
          <div class="lbl">Gross (sum)</div>
          <div class="val" id="kpiGross">—</div>
          <div class="meta">Suma GrossAmount</div>
        </div>

        <div class="kpi">
          <div class="lbl">RoomRate (sum)</div>
          <div class="val" id="kpiRoomRate">—</div>
          <div class="meta">LineItem = RoomRate</div>
        </div>

        <div class="kpi">
          <div class="lbl">Fee (sum)</div>
          <div class="val" id="kpiFee">—</div>
          <div class="meta">LineItem = Fee</div>
        </div>

        <div class="kpi">
          <div class="lbl">Tax (sum)</div>
          <div class="val" id="kpiTax">—</div>
          <div class="meta">LineItem = Tax</div>
        </div>

        <div class="kpi" style="grid-column: span 3;">
          <div class="lbl">Monto por Source</div>
          <div class="meta">Barras (sum GrossAmount, top 12) + etiquetas</div>
          <div class="mini"><canvas id="chSourceBar"></canvas></div>
        </div>

        <div class="kpi" style="grid-column: span 3;">
          <div class="lbl">Monto por Status</div>
          <div class="meta">Barras (sum GrossAmount, top 12) + etiquetas</div>
          <div class="mini"><canvas id="chStatusBar"></canvas></div>
        </div>
      </div>
    </div>
  </section>

  <!-- Resumen por huésped -->
  <section class="card">
    <div class="hd">
      <div>
        <h2>Resumen por huésped</h2>
        <div class="hint">Filtra por nombre o teléfono (usa los datos de la Tabla OTC). La evaluación de “huésped importante” se calcula automáticamente.</div>
      </div>
      <div class="hint" id="guestMeta">—</div>
    </div>

    <div class="bd">
      <div class="row" style="margin-bottom:10px; gap:10px; flex-wrap:wrap">
        <label style="flex:2; min-width:260px">
          <div class="hint">Buscar huésped (nombre o teléfono)</div>
          <input id="guestSearch" placeholder="Ej. Sofia Bucio o 528781110416" list="guestDatalist" />
          <datalist id="guestDatalist"></datalist>
        </label>

        <label class="small" style="min-width:220px">
          <div class="hint">Selección rápida</div>
          <select id="guestSelect">
            <option value="">—</option>
          </select>
        </label>
      </div>

      <div class="kpis" style="grid-template-columns: repeat(6, minmax(0, 1fr));">
        <div class="kpi">
          <div class="lbl">Clasificación</div>
          <div class="val" id="gRating">—</div>
          <div class="meta" id="gScoreMeta">—</div>
        </div>

        <div class="kpi">
          <div class="lbl">Reservas</div>
          <div class="val" id="gBookings">—</div>
          <div class="meta">IDs distintos</div>
        </div>

        <div class="kpi">
          <div class="lbl">Monto pagado</div>
          <div class="val" id="gAmount">—</div>
          <div class="meta">Suma GrossAmount (agregado por Id)</div>
        </div>

        <div class="kpi">
          <div class="lbl">Alojamientos</div>
          <div class="val" id="gHouses">—</div>
          <div class="meta" id="gHousesList">—</div>
        </div>

        <div class="kpi" style="grid-column: span 2;">
          <div class="lbl">Resumen por Source</div>
          <div class="meta">Reservas y monto (agregado por Id)</div>
          <div class="tableWrap" style="margin-top:6px">
            <div class="scrollY" style="max-height:210px">
              <table>
                <thead>
                  <tr>
                    <th class="sortable" data-key="Source">Source</th>
                    <th class="sortable" data-key="Count">Reservas</th>
                    <th class="sortable" data-key="Amount">Monto</th>
                  </tr>
                </thead>
                <tbody id="gSourceTbody"></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>

      <details style="margin-top:12px">
        <summary class="hint">Metodología de evaluación (huésped importante)</summary>
        <div class="hint" style="margin-top:8px; line-height:1.45">
          <b>Score (0–100)</b> = Reservas (0–40) + Monto (0–35) + Recurrencia (0–15) + Recencia (0–10).<br/>
          • <b>Reservas</b>: min(Reservas/5, 1) × 40<br/>
          • <b>Monto</b>: min(Monto/20000, 1) × 35 (asumiendo MXN; ajustable)<br/>
          • <b>Recurrencia</b>: min(Meses con reserva/4, 1) × 15<br/>
          • <b>Recencia</b>: si la última salida fue ≤ 180 días, hasta 10 puntos (lineal).<br/>
          <b>5★</b> si Score ≥ 85 (marcado como “importante” con ⭐ en la Tabla OTC).
        </div>
      </details>
    </div>
  </section>

  <!-- Ocupación -->
  <section class="card">
    <div class="hd">
      <div>
        <h2>Ocupación por alojamiento (por mes)</h2>
        <div class="hint">
          Se calcula con Arrival–Departure, deduplicando por <span class="mono">Id</span>.
          Vista tabla o líneas. Los filtros son combobox multiselección con checks.
        </div>
      </div>
      <div class="hint" id="occMeta">—</div>
    </div>

    <div class="bd">
      <div class="row" style="margin-bottom:10px">
        <label class="small">
          <div class="hint">Vista</div>
          <select id="occView">
            <option value="table">Tabla</option>
            <option value="line">Gráfica de líneas (% ocupación)</option>
          </select>
        </label>

        <!-- ✅ combobox multi: Propiedad (ocupación) -->
        <div class="mcb" id="mcbOccPropiedad" style="flex:1.2">
          <div class="hint">Propiedad</div>
          <button class="mcbBtn" type="button">
            <span class="mcbLabel">Todas</span>
            <span class="caret">▾</span>
          </button>
          <div class="mcbPanel">
            <input class="mcbSearch" type="text" placeholder="Buscar propiedad..." />
            <div class="mcbTools">
              <button type="button" class="mcbAll">Seleccionar todo</button>
              <button type="button" class="mcbNone">Limpiar</button>
            </div>
            <div class="mcbList"></div>
            <div class="mcbFooter">
              <span class="mcbCount">0 seleccionados</span>
              <button type="button" class="mcbClose">Cerrar</button>
            </div>
          </div>
        </div>

        <!-- ✅ combobox multi: Alojamientos -->
        <div class="mcb" id="mcbOccHouses" style="flex:2">
          <div class="hint">Alojamientos (HouseName)</div>
          <button class="mcbBtn" type="button">
            <span class="mcbLabel">Todos</span>
            <span class="caret">▾</span>
          </button>
          <div class="mcbPanel">
            <input class="mcbSearch" type="text" placeholder="Buscar alojamiento..." />
            <div class="mcbTools">
              <button type="button" class="mcbAll">Seleccionar todo</button>
              <button type="button" class="mcbNone">Limpiar</button>
            </div>
            <div class="mcbList"></div>
            <div class="mcbFooter">
              <span class="mcbCount">0 seleccionados</span>
              <button type="button" class="mcbClose">Cerrar</button>
            </div>
          </div>
        </div>

        <div class="hint" style="flex:2; align-self:end">
          Tip: si no seleccionas nada, se asume “todos”.
        </div>
      </div>

      <!-- Line chart -->
      <div id="occLineWrap" class="tableWrap" style="display:none;">
        <div style="height:420px; padding:10px;">
          <canvas id="occLineChart"></canvas>
        </div>
      </div>

      <!-- Table -->
      <div id="occTableWrap" class="tableWrap">
        <div class="occScroll">
          <table id="occTable">
            <thead id="occThead"></thead>
            <tbody id="occTbody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </section>

  <!-- Tabla OTC -->
  <section class="card">
    <div class="hd">
      <div>
        <h2>Tabla OTC</h2>
        <div class="row" style="margin-top:8px; gap:8px; flex-wrap:wrap">
          <button id="btnAgg" class="ghost" type="button">Ver montos agregados</button>
          <span class="hint">En modo agregado: 1 fila por <span class="mono">Id</span> (suma GrossAmount)</span>
        </div>
        <div class="hint">Tabla + filtros instantáneos + overlap por fechas</div>
      </div>
    </div>

    <div class="bd">
      <div class="tableWrap">
        <div class="scrollY">
          <table>
            <thead>
              <tr>
                <th data-key="Id" class="sortable">Id</th>
                <th data-key="Property" class="sortable">Propiedad</th>
                <th data-key="Source" class="sortable">Source</th>
                <th data-key="Status" class="sortable">Status</th>
                <th data-key="DateArrival" class="sortable">Arrival</th>
                <th data-key="DateDeparture" class="sortable">Departure</th>
                <th data-key="Nights" class="sortable">Nights</th>
                <th data-key="HouseName" class="sortable">HouseName</th>
                <th data-key="GuestName" class="sortable">GuestName</th>
                <th data-key="GuestEmail" class="sortable">GuestEmail</th>
                <th data-key="GuestPhone" class="sortable">GuestPhone</th>
                <th data-key="GuestCountryCode" class="sortable">CountryCode</th>
                <th data-key="LineItem" class="sortable">LineItem</th>
                <th data-key="GrossAmount" class="sortable">GrossAmount</th>
                <th data-key="Currency" class="sortable">Currency</th>
              </tr>
            </thead>
            <tbody id="tbody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="footer">
      Export CSV usa: <span class="mono">/api/otc.csv</span>
    </div>
  </section>

</main>

<script>
  // Si abres desde GitHub Pages, define aquí tu Cloud Run:
  // const API_BASE = "https://checkinnreservas-1044570371371.northamerica-south1.run.app";
  const API_BASE = "";

  let rowsRaw = [];
  let rowsFiltered = [];
  let otcAggMode = false; // false: line items, true: agregado por Id
  let otcSort = { key: "DateArrival", dir: "desc" };
  let occSort = { key: "HouseName", dir: "asc" };
  let guestIndex = { byKey: new Map(), byBookingId: new Map(), list: [] }; // computed from rowsFiltered (agregado por Id)

  // Charts
  let chSourceBar = null;
  let chStatusBar = null;
  let chOccLines = null;

  // Ocupación series cache
  let occSeries = null; // { months:[...], houses:[...], pctByHouse: Map(house -> [pct...]) }

  // Multi-combobox state: id -> {items:[...], selected:Set, onChange(fn), labelEl, listEl, searchEl, countEl}
  const mcb = new Map();

  const $ = (id) => document.getElementById(id);

  function setStatus(kind, text){
    const el = $("apiStatus");
    const dot = el.querySelector(".dot");
    dot.classList.remove("ok","err","busy");
    dot.classList.add(kind);
    el.lastElementChild.textContent = text;
  }

  function moneyMXN(v){
    const n = Number(v);
    if(!Number.isFinite(n)) return "—";
    try{ return new Intl.NumberFormat("es-MX",{style:"currency",currency:"MXN"}).format(n); }
    catch{ return "$" + n.toFixed(2); }
  }

  function safeStr(v){ return (v === null || v === undefined) ? "" : String(v); }
  function safeNum(v){ const n = Number(v); return Number.isFinite(n) ? n : 0; }

  // ===== Propiedad derivada de HouseName =====
  function propertyFromHouse(house){
    let s = safeStr(house).trim();
    if(!s) return "—";
    s = s.replace(/\s*\([^)]*\)\s*$/g, "").trim();        // quita paréntesis final
    if (s.includes("#")) s = s.split("#")[0].trim();      // corta en #
    s = s.split(" - ")[0].split(" – ")[0].trim();         // cortes extra
    s = s.replace(/\s{2,}/g, " ").trim();
    return s || "—";
  }

  // Arrival/Departure vienen como "MM/DD/YYYY"
  function parseMMDDYYYY(s){
    const t = safeStr(s).trim();
    if(!t) return null;
    const m = t.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if(!m) return null;
    const mm = Number(m[1]), dd = Number(m[2]), yyyy = Number(m[3]);
    if(!mm || !dd || !yyyy) return null;
    return new Date(Date.UTC(yyyy, mm-1, dd, 0, 0, 0));
  }
  function parseISODateInput(s){
    const t = safeStr(s).trim();
    if(!t) return null;
    const m = t.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if(!m) return null;
    const yyyy = Number(m[1]), mm = Number(m[2]), dd = Number(m[3]);
    return new Date(Date.UTC(yyyy, mm-1, dd, 0, 0, 0));
  }

  // overlap: [aStart, aEnd) toca [bStart, bEnd) si aStart < bEnd && bStart < aEnd
  function overlaps(arrivalMMDD, departureMMDD, fromISO, toISO){
    const aStart = parseMMDDYYYY(arrivalMMDD);
    const aEnd   = parseMMDDYYYY(departureMMDD);
    const bStart = parseISODateInput(fromISO);
    const bEnd   = parseISODateInput(toISO);
    if(!aStart || !aEnd || !bStart || !bEnd) return true;

    const bEndEx = new Date(bEnd.getTime());
    bEndEx.setUTCDate(bEndEx.getUTCDate() + 1); // end exclusivo (to inclusive)
    return (aStart < bEndEx) && (bStart < aEnd);
  }

  function qs(){
    const from = $("from").value;
    const to = $("to").value;
    return new URLSearchParams({ from, to }).toString();
  }

  function normalizeRow(r){
    const house = r.HouseName;
    const prop = propertyFromHouse(house);
    return {
      Id: r.Id,
      Property: prop,
      Source: r.Source,
      Status: r.Status,
      DateArrival: r.DateArrival,
      DateDeparture: r.DateDeparture,
      Nights: safeNum(r.Nights),
      HouseName: r.HouseName,
      GuestName: r.GuestName,
      GuestEmail: r.GuestEmail,
      GuestPhone: r.GuestPhone,
      GuestCountryCode: r.GuestCountryCode,
      LineItem: r.LineItem,
      GrossAmount: safeNum(r.GrossAmount),
      Currency: r.Currency,
      _raw: r
    };
  }

  async function fetchOTC(){
    setStatus("busy", "Cargando...");
    $("metaLine").textContent = "—";

    const url = `${API_BASE}/api/otc?${qs()}`;
    const res = await fetch(url, { headers: { "Accept":"application/json" } });
    const data = await res.json();

    if(!res.ok || !data?.ok){
      setStatus("err", "Error");
      throw new Error(data?.error || `HTTP ${res.status}`);
    }

    rowsRaw = (data.rows || []).map(normalizeRow);
    setStatus("ok", `OK · ${rowsRaw.length} filas`);

    const metaBits = [
      `bookingsFetched=${data.bookingsFetched ?? "?"}`,
      `pagesUsed=${data.pagesUsed ?? "?"}`,
      `effectivePageSize=${data.effectivePageSize ?? "?"}`,
      `totalCount=${data.totalCount ?? "?"}`
    ];
    $("metaLine").textContent = metaBits.join(" · ");

    rebuildSingleSelects();
    rebuildPropiedadMCBFromRowsRaw();
    applyLocalFilters(); // instant
  }

  async function loadDebug(){
    setStatus("busy", "Debug...");
    const url = `${API_BASE}/api/debug/bookings`;
    const res = await fetch(url, { headers: { "Accept":"application/json" } });
    const data = await res.json();
    if(!res.ok || !data?.ok){
      setStatus("err","Debug error");
      alert(data?.error || `HTTP ${res.status}`);
      return;
    }
    setStatus("ok","Debug OK");
    alert(
      [
        "Debug paginación Lodgify",
        `effectivePageSize: ${data.effectivePageSize}`,
        `pagesUsed: ${data.pagesUsed}`,
        `totalCount: ${data.totalCount}`,
        `bookingsFetched: ${data.bookingsFetched}`,
        `arrivalMin: ${data.arrivalMin}`,
        `arrivalMax: ${data.arrivalMax}`,
      ].join("\n")
    );
  }

  function rebuildSingleSelects(){
    // Source
    const selS = $("selSource");
    const curS = selS.value;
    const sources = [...new Set(rowsRaw.map(r => safeStr(r.Source).trim()).filter(Boolean))]
      .sort((a,b)=>a.localeCompare(b));
    selS.innerHTML = `<option value="">Todos</option>` + sources.map(s => `<option value="${escapeHtml(s)}">${escapeHtml(s)}</option>`).join("");
    selS.value = sources.includes(curS) ? curS : "";

    // Status
    const selSt = $("selStatus");
    const curSt = selSt.value;
    const statuses = [...new Set(rowsRaw.map(r => safeStr(r.Status).trim()).filter(Boolean))]
      .sort((a,b)=>a.localeCompare(b));
    selSt.innerHTML = `<option value="">Todos</option>` + statuses.map(s => `<option value="${escapeHtml(s)}">${escapeHtml(s)}</option>`).join("");
    selSt.value = statuses.includes(curSt) ? curSt : "";
  }

  // ===== Multi-combobox implementation =====
  function initMCB(containerId, { emptyLabel="Todas", onChange=()=>{} }={}){
    const root = $(containerId);
    const btn = root.querySelector(".mcbBtn");
    const labelEl = root.querySelector(".mcbLabel");
    const panel = root.querySelector(".mcbPanel");
    const listEl = root.querySelector(".mcbList");
    const searchEl = root.querySelector(".mcbSearch");
    const countEl = root.querySelector(".mcbCount");
    const btnAll = root.querySelector(".mcbAll");
    const btnNone = root.querySelector(".mcbNone");
    const btnClose = root.querySelector(".mcbClose");

    const state = {
      items: [],
      selected: new Set(),
      emptyLabel,
      onChange,
      root, btn, labelEl, panel, listEl, searchEl, countEl
    };
    mcb.set(containerId, state);

    function open(){ root.classList.add("open"); searchEl.focus(); }
    function close(){ root.classList.remove("open"); }

    btn.addEventListener("click", (e)=>{
      e.preventDefault();
      root.classList.contains("open") ? close() : open();
    });

    btnClose.addEventListener("click", (e)=>{ e.preventDefault(); close(); });

    document.addEventListener("click", (e)=>{
      if(!root.contains(e.target)) close();
    });

    searchEl.addEventListener("input", ()=> renderMCB(containerId));

    btnAll.addEventListener("click", (e)=>{
      e.preventDefault();
      state.selected = new Set(state.items);
      updateMCBLabel(containerId);
      renderMCB(containerId);
      state.onChange(getMCBSelected(containerId));
    });

    btnNone.addEventListener("click", (e)=>{
      e.preventDefault();
      state.selected = new Set();
      updateMCBLabel(containerId);
      renderMCB(containerId);
      state.onChange(getMCBSelected(containerId));
    });
  }

  function setMCBItems(containerId, items, keepSelected=true){
    const state = mcb.get(containerId);
    state.items = [...items];
    if(!keepSelected){
      state.selected = new Set();
    } else {
      // limpia selecciones inexistentes
      const next = new Set();
      for(const v of state.selected){
        if(state.items.includes(v)) next.add(v);
      }
      state.selected = next;
    }
    updateMCBLabel(containerId);
    renderMCB(containerId);
  }

  function getMCBSelected(containerId){
    return [...(mcb.get(containerId)?.selected || [])];
  }

  function updateMCBLabel(containerId){
    const state = mcb.get(containerId);
    const n = state.selected.size;
    if(n === 0){
      state.labelEl.textContent = state.emptyLabel;
    } else if (n === 1){
      state.labelEl.textContent = [...state.selected][0];
    } else {
      state.labelEl.textContent = `${n} seleccionados`;
    }
    state.countEl.textContent = `${n} seleccionados`;
  }

  function renderMCB(containerId){
    const state = mcb.get(containerId);
    const q = state.searchEl.value.trim().toLowerCase();

    const filtered = state.items.filter(v => v.toLowerCase().includes(q));
    state.listEl.innerHTML = filtered.map(v=>{
      const checked = state.selected.has(v) ? "checked" : "";
      const id = `${containerId}__${hashId(v)}`;
      return `
        <div class="mcbItem">
          <label for="${id}">
            <input id="${id}" type="checkbox" ${checked} data-value="${escapeHtml(v)}" />
            <span>${escapeHtml(v)}</span>
          </label>
        </div>
      `;
    }).join("") || `<div class="mcbItem"><span class="hint">Sin resultados</span></div>`;

    // listeners a los checks
    state.listEl.querySelectorAll('input[type="checkbox"]').forEach(chk=>{
      chk.addEventListener("change", ()=>{
        const v = chk.getAttribute("data-value");
        const val = unescapeHtml(v);
        if(chk.checked) state.selected.add(val);
        else state.selected.delete(val);
        updateMCBLabel(containerId);
        state.onChange(getMCBSelected(containerId));
      });
    });

    updateMCBLabel(containerId);
  }

  function hashId(s){
    // hash simple para ids
    let h = 0;
    for (let i=0; i<s.length; i++) h = ((h<<5)-h) + s.charCodeAt(i) | 0;
    return String(Math.abs(h));
  }

  function escapeHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }
  function unescapeHtml(s){
    // solo para nuestros values
    return String(s ?? "")
      .replaceAll("&amp;","&")
      .replaceAll("&lt;","<")
      .replaceAll("&gt;",">")
      .replaceAll("&quot;",'"')
      .replaceAll("&#039;","'");
  }

  function normalizePhoneDigits(phone){
    const raw = safeStr(phone).trim();
    if(!raw) return "";
    return raw.replace(/\D/g, "");
  }

  function renderWhatsAppPhone(phone){
    const raw = safeStr(phone).trim();
    if(!raw) return "—";
    const digits = normalizePhoneDigits(raw);
    if(!digits) return escapeHtml(raw);
    const href = `https://wa.me/${digits}`;
    return `<a href="${href}" target="_blank" rel="noopener noreferrer">${escapeHtml(raw)}</a>`;
  }


  function rebuildPropiedadMCBFromRowsRaw(){
    const props = [...new Set(rowsRaw.map(r => safeStr(r.Property).trim()).filter(Boolean))]
      .sort((a,b)=>a.localeCompare(b));
    setMCBItems("mcbPropiedad", props, true);
  }

  // ===== Filters =====
  function applyLocalFilters(){
    const q = $("q").value.trim().toLowerCase();
    const src = $("selSource").value.trim().toLowerCase();
    const st = $("selStatus").value.trim().toLowerCase();
    const fromISO = $("from").value;
    const toISO = $("to").value;

    const propsSelected = getMCBSelected("mcbPropiedad").map(x=>x.toLowerCase());
    const hasPropFilter = propsSelected.length > 0;

    rowsFiltered = rowsRaw.filter(r=>{
      if(fromISO && toISO){
        if(!overlaps(r.DateArrival, r.DateDeparture, fromISO, toISO)) return false;
      }
      if(hasPropFilter){
        const rp = safeStr(r.Property).toLowerCase();
        if(!propsSelected.includes(rp)) return false;
      }
      if(src && safeStr(r.Source).toLowerCase() !== src) return false;
      if(st && safeStr(r.Status).toLowerCase() !== st) return false;

      if(!q) return true;
      const hay = [r.Id,r.Property,r.Source,r.Status,r.HouseName,r.GuestName,r.LineItem,r.Currency].join(" ").toLowerCase();
      return hay.includes(q);
    });

    renderKPIs();
    renderMiniChartsByAmount();
    renderOccupancyByMonth();
    renderTable();
  }

  // ===== KPIs =====
  function sumByLineItem(name){
    const key = String(name || "").toLowerCase();
    return rowsFiltered.reduce((acc, r)=>{
      if(safeStr(r.LineItem).toLowerCase() === key) return acc + safeNum(r.GrossAmount);
      return acc;
    }, 0);
  }

  function renderKPIs(){
    $("pillFiltered").textContent = `${rowsFiltered.length.toLocaleString("es-MX")} filas`;

    const uniq = new Set(rowsFiltered.map(r => safeStr(r.Id))).size;
    $("kpiBookings").textContent = uniq.toLocaleString("es-MX");

    const nights = rowsFiltered.reduce((a,r)=>a + safeNum(r.Nights), 0);
    $("kpiNights").textContent = nights.toLocaleString("es-MX");

    const gross = rowsFiltered.reduce((a,r)=// ===== Table OTC =====
  function aggregateByBookingId(rows){
    const m = new Map(); // id -> aggRow
    for(const r of rows){
      const id = safeStr(r.Id);
      if(!id) continue;
      if(!m.has(id)){
        m.set(id, {
          ...r,
          LineItem: "TOTAL",
          GrossAmount: 0
        });
      }
      const a = m.get(id);
      a.GrossAmount += safeNum(r.GrossAmount);
      // Keep first non-empty guest fields if missing
      if(!a.GuestEmail) a.GuestEmail = r.GuestEmail;
      if(!a.GuestPhone) a.GuestPhone = r.GuestPhone;
      if(!a.GuestCountryCode) a.GuestCountryCode = r.GuestCountryCode;
      if(!a.GuestName) a.GuestName = r.GuestName;
      if(!a.HouseName) a.HouseName = r.HouseName;
      if(!a.Property) a.Property = r.Property;
      if(!a.Source) a.Source = r.Source;
      if(!a.Status) a.Status = r.Status;
      if(!a.DateArrival) a.DateArrival = r.DateArrival;
      if(!a.DateDeparture) a.DateDeparture = r.DateDeparture;
      if(!a.Nights) a.Nights = r.Nights;
      if(!a.Currency) a.Currency = r.Currency;
    }
    return [...m.values()];
  }

  function getComparableValue(row, key){
    const k = String(key || "");
    if(k === "Nights" || k === "GrossAmount") return safeNum(row[k]);
    if(k === "DateArrival" || k === "DateDeparture"){
      const d = parseMMDDYYYY(row[k]);
      return d ? d.getTime() : 0;
    }
    return safeStr(row[k]).toLowerCase();
  }

  function sortRows(rows, sortState){
    const { key, dir } = sortState || {};
    if(!key) return rows;
    const mult = (dir === "asc") ? 1 : -1;
    return [...rows].sort((a,b)=>{
      const va = getComparableValue(a, key);
      const vb = getComparableValue(b, key);
      if(va < vb) return -1*mult;
      if(va > vb) return  1*mult;
      // tie-break
      const ia = safeStr(a.Id).toLowerCase();
      const ib = safeStr(b.Id).toLowerCase();
      return ia.localeCompare(ib) * mult;
    });
  }

  function computeGuestIndexFromRows(rowsAgg){
    const byKey = new Map();
    const byBookingId = new Map();

    function guestKeyOf(r){
      const phone = normalizePhoneDigits(r.GuestPhone);
      if(phone) return `p:${phone}`;
      const name = safeStr(r.GuestName).trim().toLowerCase();
      return name ? `n:${name}` : "n:—";
    }

    // First pass: group
    for(const r of rowsAgg){
      const key = guestKeyOf(r);
      if(!byKey.has(key)){
        byKey.set(key, {
          key,
          name: safeStr(r.GuestName).trim() || "—",
          phone: normalizePhoneDigits(r.GuestPhone) || "",
          phoneRaw: safeStr(r.GuestPhone).trim() || "",
          email: safeStr(r.GuestEmail).trim() || "",
          country_code: safeStr(r.GuestCountryCode).trim() || "",
          bookingIds: new Set(),
          amount: 0,
          houses: new Set(),
          props: new Set(),
          months: new Set(),
          lastDeparture: null,
          sources: new Map(), // source -> {count, amount}
        });
      }
      const g = byKey.get(key);
      g.bookingIds.add(safeStr(r.Id));
      g.amount += safeNum(r.GrossAmount);
      if(r.HouseName) g.houses.add(safeStr(r.HouseName));
      if(r.Property) g.props.add(safeStr(r.Property));
      if(r.Source){
        const s = safeStr(r.Source) || "—";
        if(!g.sources.has(s)) g.sources.set(s, { count:0, amount:0 });
        const ss = g.sources.get(s);
        ss.count += 1;
        ss.amount += safeNum(r.GrossAmount);
      }
      // month key from arrival
      const dA = parseMMDDYYYY(r.DateArrival);
      if(dA){
        const mk = `${dA.getUTCFullYear()}-${String(dA.getUTCMonth()+1).padStart(2,"0")}`;
        g.months.add(mk);
      }
      const dD = parseMMDDYYYY(r.DateDeparture);
      if(dD){
        if(!g.lastDeparture || dD.getTime() > g.lastDeparture.getTime()) g.lastDeparture = dD;
      }
      byBookingId.set(safeStr(r.Id), key);
    }

    // Second pass: scoring
    const now = new Date();
    const list = [];
    for(const g of byKey.values()){
      const bookings = g.bookingIds.size;
      const amount = g.amount;
      const recur = g.months.size;

      const ptsBookings = Math.min(bookings/5, 1) * 40;
      const ptsAmount = Math.min(amount/20000, 1) * 35;
      const ptsRecur = Math.min(recur/4, 1) * 15;

      let ptsRecency = 0;
      if(g.lastDeparture){
        const days = Math.max(0, (now.getTime() - g.lastDeparture.getTime()) / (1000*60*60*24));
        const x = Math.max(0, 1 - (days/180));
        ptsRecency = x * 10;
      }

      const score = Math.round(ptsBookings + ptsAmount + ptsRecur + ptsRecency);
      let stars = 1;
      if(score >= 85) stars = 5;
      else if(score >= 70) stars = 4;
      else if(score >= 55) stars = 3;
      else if(score >= 35) stars = 2;

      g.score = score;
      g.stars = stars;
      g.isImportant = (stars === 5);

      list.push(g);
    }

    // Sort guests by score desc
    list.sort((a,b)=> (b.score-a.score) || (b.bookingIds.size-a.bookingIds.size) || (b.amount-a.amount));

    guestIndex = { byKey, byBookingId, list };
    rebuildGuestPickers();
    renderGuestSummary(); // refresh current selection
  }

  function rebuildGuestPickers(){
    // Build datalist + select from guestIndex.list
    const dl = $("guestDatalist");
    const sel = $("guestSelect");
    if(!dl || !sel) return;

    const curSel = sel.value;

    const opts = guestIndex.list.slice(0, 400); // limit for UI
    dl.innerHTML = opts.map(g=>{
      const label = [g.name, g.phoneRaw || g.phone, g.email].filter(Boolean).join(" · ");
      return `<option value="${escapeHtml(label)}"></option>`;
    }).join("");

    sel.innerHTML = `<option value="">—</option>` + opts.map(g=>{
      const phone = g.phoneRaw || (g.phone ? `+${g.phone}` : "");
      const tag = g.isImportant ? " ⭐" : "";
      const text = `${g.name}${phone ? " · " + phone : ""}${tag}`;
      return `<option value="${escapeHtml(g.key)}">${escapeHtml(text)}</option>`;
    }).join("");

    sel.value = (curSel && [...guestIndex.byKey.keys()].includes(curSel)) ? curSel : "";
    $("guestMeta").textContent = `${guestIndex.list.length.toLocaleString("es-MX")} huéspedes detectados`;
  }

  function pickGuestKeyFromSearch(str){
    const q = safeStr(str).trim().toLowerCase();
    if(!q) return "";
    const digits = normalizePhoneDigits(q);
    if(digits){
      const key = `p:${digits}`;
      if(guestIndex.byKey.has(key)) return key;
    }
    // try exact name match
    const key2 = `n:${q}`;
    if(guestIndex.byKey.has(key2)) return key2;

    // fuzzy: contains
    for(const g of guestIndex.list){
      const hay = `${g.name} ${g.phoneRaw} ${g.phone} ${g.email}`.toLowerCase();
      if(hay.includes(q)) return g.key;
    }
    return "";
  }

  function renderGuestSummary(){
    const keyFromSelect = $("guestSelect")?.value || "";
    const keyFromSearch = pickGuestKeyFromSearch($("guestSearch")?.value || "");
    const key = keyFromSelect || keyFromSearch;

    if(!key || !guestIndex.byKey.has(key)){
      $("gRating").textContent = "—";
      $("gScoreMeta").textContent = "—";
      $("gBookings").textContent = "—";
      $("gAmount").textContent = "—";
      $("gHouses").textContent = "—";
      $("gHousesList").textContent = "—";
      $("gSourceTbody").innerHTML = "";
      return;
    }

    const g = guestIndex.byKey.get(key);
    $("gRating").textContent = `${"★".repeat(g.stars)}${"☆".repeat(5-g.stars)}`;
    $("gScoreMeta").textContent = `Score: ${g.score}/100${g.isImportant ? " · Importante ⭐" : ""}`;

    $("gBookings").textContent = g.bookingIds.size.toLocaleString("es-MX");
    $("gAmount").textContent = moneyMXN(g.amount);

    $("gHouses").textContent = g.houses.size.toLocaleString("es-MX");
    const housesTxt = [...g.houses].slice(0,10).join(", ") + (g.houses.size>10 ? "…" : "");
    $("gHousesList").textContent = housesTxt || "—";

    // source table
    const rows = [...g.sources.entries()].map(([Source, v])=>({ Source, Count: v.count, Amount: v.amount }))
      .sort((a,b)=> (b.Amount-a.Amount) || (b.Count-a.Count) || a.Source.localeCompare(b.Source));

    $("gSourceTbody").innerHTML = rows.map(r=>`
      <tr>
        <td>${escapeHtml(r.Source)}</td>
        <td class="mono">${r.Count.toLocaleString("es-MX")}</td>
        <td class="mono">${moneyMXN(r.Amount)}</td>
      </tr>
    `).join("");
  }

  function renderTable(){
    const tb = $("tbody");
    tb.innerHTML = "";

    // choose view
    const rowsView = otcAggMode ? aggregateByBookingId(rowsFiltered) : rowsFiltered;

    // compute guest index from aggregated view (always)
    computeGuestIndexFromRows(aggregateByBookingId(rowsFiltered));

    // sort
    const rowsSorted = sortRows(rowsView, otcSort);

    const frag = document.createDocumentFragment();
    for(const r of rowsSorted){
      const id = safeStr(r.Id) || "—";
      const guestKey = guestIndex.byBookingId.get(safeStr(r.Id));
      const g = guestKey ? guestIndex.byKey.get(guestKey) : null;
      const star = (g && g.isImportant) ? '<span class="s">⭐</span>' : '';

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="mono">
          <span class="vipStar">${star}<span>${escapeHtml(id)}</span></span>
        </td>
        <td>${escapeHtml(safeStr(r.Property) || "—")}</td>
        <td>${escapeHtml(safeStr(r.Source) || "—")}</td>
        <td>${escapeHtml(safeStr(r.Status) || "—")}</td>
        <td class="mono">${escapeHtml(safeStr(r.DateArrival) || "—")}</td>
        <td class="mono">${escapeHtml(safeStr(r.DateDeparture) || "—")}</td>
        <td class="mono">${safeNum(r.Nights) || 0}</td>
        <td title="${escapeHtml(safeStr(r.HouseName))}">${escapeHtml(safeStr(r.HouseName) || "—")}</td>
        <td title="${escapeHtml(safeStr(r.GuestName))}">${escapeHtml(safeStr(r.GuestName) || "—")}</td>
        <td title="${escapeHtml(safeStr(r.GuestEmail))}">${escapeHtml(safeStr(r.GuestEmail) || "—")}</td>
        <td class="mono" title="${escapeHtml(safeStr(r.GuestPhone))}">${renderWhatsAppPhone(r.GuestPhone)}</td>
        <td class="mono">${escapeHtml(safeStr(r.GuestCountryCode) || "—")}</td>
        <td>${escapeHtml(safeStr(r.LineItem) || "—")}</td>
        <td class="mono">${moneyMXN(r.GrossAmount)}</td>
        <td class="mono">${escapeHtml(safeStr(r.Currency) || "—")}</td>
      `;
      frag.appendChild(tr);
    }
    tb.appendChild(frag);
  }
safeStr(r.GuestName) || "—")}</td>
        <td>${escapeHtml(safeStr(r.LineItem) || "—")}</td>
        <td class="mono">${moneyMXN(r.GrossAmount)}</td>
        <td class="mono">${escapeHtml(safeStr(r.Currency) || "—")}</td>
      `;
      frag.appendChild(tr);
    }
    tb.appendChild(frag);
  }

  // ===== Mini charts with bar labels =====
  function buildSum(field){
    const m = new Map();
    for(const r of rowsFiltered){
      const k = safeStr(r[field]).trim() || "—";
      m.set(k, (m.get(k) || 0) + safeNum(r.GrossAmount));
    }
    const labels = [...m.keys()].sort((a,b)=> (m.get(b)-m.get(a)));
    const data = labels.map(k => m.get(k));
    return { labels, data };
  }

  // Plugin: etiquetas encima de cada barra (sin librerías extra)
  const barValueLabels = {
    id: "barValueLabels",
    afterDatasetsDraw(chart, args, pluginOptions){
      const { ctx } = chart;
      const fmt = pluginOptions?.format || ((v)=>String(v));
      const offset = pluginOptions?.offset ?? 6;
      const color = pluginOptions?.color || "rgba(232,238,252,.9)";
      const fontSize = pluginOptions?.fontSize || 11;

      ctx.save();
      ctx.fillStyle = color;
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      ctx.font = `${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;

      chart.data.datasets.forEach((dataset, di)=>{
        const meta = chart.getDatasetMeta(di);
        meta.data.forEach((el, i)=>{
          const v = dataset.data[i];
          if(v === null || v === undefined) return;
          const p = el.tooltipPosition();
          ctx.fillText(fmt(v), p.x, p.y - offset);
        });
      });

      ctx.restore();
    }
  };

  function renderMiniChartsByAmount(){
    const src = buildSum("Source");
    const st  = buildSum("Status");

    const srcLabels = src.labels.slice(0,12);
    const srcData   = src.data.slice(0,12);

    const stLabels = st.labels.slice(0,12);
    const stData   = st.data.slice(0,12);

    if(chSourceBar) chSourceBar.destroy();
    if(chStatusBar) chStatusBar.destroy();

    const fmtMoneyShort = (v)=>{
      const n = Number(v)||0;
      // abreviación simple (K/M)
      const abs = Math.abs(n);
      if(abs >= 1_000_000) return (n/1_000_000).toFixed(1) + "M";
      if(abs >= 1_000) return (n/1_000).toFixed(1) + "K";
      return String(Math.round(n));
    };

    chSourceBar = new Chart($("chSourceBar"), {
      type: "bar",
      data: { labels: srcLabels, datasets: [{ label:"Monto", data: srcData }] },
      options: {
        responsive:true,
        maintainAspectRatio:false,
        plugins:{
          legend:{ display:false },
          tooltip:{ enabled:true, callbacks:{ label: (ctx)=> ` ${moneyMXN(ctx.raw)}` } },
          barValueLabels: { format: fmtMoneyShort, offset: 6, fontSize: 11 }
        },
        scales:{ y:{ beginAtZero:true } }
      },
      plugins: [barValueLabels]
    });

    chStatusBar = new Chart($("chStatusBar"), {
      type: "bar",
      data: { labels: stLabels, datasets: [{ label:"Monto", data: stData }] },
      options: {
        responsive:true,
        maintainAspectRatio:false,
        plugins:{
          legend:{ display:false },
          tooltip:{ enabled:true, callbacks:{ label: (ctx)=> ` ${moneyMXN(ctx.raw)}` } },
          barValueLabels: { format: fmtMoneyShort, offset: 6, fontSize: 11 }
        },
        scales:{ y:{ beginAtZero:true } }
      },
      plugins: [barValueLabels]
    });
  }

  // ===== Occupancy helpers =====
  function monthStartUTC(y, m0){ return new Date(Date.UTC(y, m0, 1, 0, 0, 0)); }
  function monthEndUTCExclusive(y, m0){ return new Date(Date.UTC(y, m0+1, 1, 0, 0, 0)); }
  function daysBetweenUTC(a, b){
    const ms = b.getTime() - a.getTime();
    return Math.max(0, Math.round(ms / 86400000));
  }
  function intersectNights(aStart, aEndEx, bStart, bEndEx){
    const s = (aStart > bStart) ? aStart : bStart;
    const e = (aEndEx < bEndEx) ? aEndEx : bEndEx;
    return daysBetweenUTC(s, e);
  }
  function monthsBetween(fromISO, toISO){
    const a = parseISODateInput(fromISO);
    const b = parseISODateInput(toISO);
    if(!a || !b) return [];

    const out = [];
    let y = a.getUTCFullYear();
    let m = a.getUTCMonth();
    const y2 = b.getUTCFullYear();
    const m2 = b.getUTCMonth();

    while (y < y2 || (y === y2 && m <= m2)){
      out.push({ y, m0: m, key: `${y}-${String(m+1).padStart(2,"0")}` });
      m++;
      if(m > 11){ m = 0; y++; }
    }
    return out;
  }

  function rebuildOccMCBsFromContext(availableProps, availableHouses){
    // Propiedad (ocupación)
    setMCBItems("mcbOccPropiedad", availableProps, true);

    // Alojamientos
    setMCBItems("mcbOccHouses", availableHouses, true);
  }

  function renderOccupancyByMonth(){
    const fromISO = $("from").value;
    const toISO = $("to").value;
    const months = monthsBetween(fromISO, toISO);

    const thead = $("occThead");
    const tbody = $("occTbody");
    thead.innerHTML = "";
    tbody.innerHTML = "";

    if(!months.length){
      $("occMeta").textContent = "Selecciona Desde/Hasta para calcular ocupación.";
      occSeries = null;
      renderOccLineChart();
      return;
    }

    // Deduplicar por Id para no contar múltiples line items
    const bookings = new Map(); // id -> {house, property, startUTC, endUTCEx}
    for(const r of rowsFiltered){
      const id = safeStr(r.Id);
      if(!id) continue;
      if(bookings.has(id)) continue;

      const start = parseMMDDYYYY(r.DateArrival);
      const endEx = parseMMDDYYYY(r.DateDeparture);
      const house = safeStr(r.HouseName).trim() || "—";
      const prop  = safeStr(r.Property).trim() || propertyFromHouse(house);

      if(!start || !endEx) continue;
      bookings.set(id, { house, property: prop, start, endEx });
    }

    // nights per house/month
    const map = new Map(); // house -> Map(monthKey -> nights)
    const propertyByHouse = new Map();
    const houseSet = new Set();
    const propSet = new Set();

    for(const b of bookings.values()){
      houseSet.add(b.house);
      propertyByHouse.set(b.house, b.property);
      propSet.add(b.property);

      for(const mo of months){
        const ms = monthStartUTC(mo.y, mo.m0);
        const me = monthEndUTCExclusive(mo.y, mo.m0);
        const n = intersectNights(b.start, b.endEx, ms, me);
        if(n <= 0) continue;

        if(!map.has(b.house)) map.set(b.house, new Map());
        const hm = map.get(b.house);
        hm.set(mo.key, (hm.get(mo.key) || 0) + n);
      }
    }

    // Available props/houses for occupancy filters (según rowsFiltered)
    const availableProps = [...propSet].sort((a,b)=>a.localeCompare(b));
    const availableHousesAll = [...houseSet].sort((a,b)=>a.localeCompare(b));

    // Rebuild occupancy MCBs with available items (keep selected if possible)
    rebuildOccMCBsFromContext(availableProps, availableHousesAll);
    setMCBItems("mcbOccAvgMonths", months.map(m=>m.key), true);

    // Apply occupancy-local property filter
    const occProps = getMCBSelected("mcbOccPropiedad").map(s=>s.toLowerCase());
    const occHasProp = occProps.length > 0;

    let housesAvailable = availableHousesAll.filter(h=>{
      if(!occHasProp) return true;
      const p = safeStr(propertyByHouse.get(h)).toLowerCase();
      return occProps.includes(p);
    }).sort((a,b)=>a.localeCompare(b));

    // Update houses list to only those matching property selection (keeping selection)
    setMCBItems("mcbOccHouses", housesAvailable, true);

    // Apply occupancy-local house filter
    const occHousesSel = getMCBSelected("mcbOccHouses");
    const occHasHouse = occHousesSel.length > 0;
    const occHouseSet = new Set(occHousesSel);

    const housesToShow0 = housesAvailable.filter(h => !occHasHouse || occHouseSet.has(h));

    // Promedio sobre meses seleccionados (si no seleccionas, usa todos)
    const avgSel = getMCBSelected("mcbOccAvgMonths");
    const avgKeys = new Set((avgSel && avgSel.length) ? avgSel : months.map(m=>m.key));

    function pctFor(house, monthKey){
      const hm = map.get(house) || new Map();
      const mo = months.find(x=>x.key===monthKey);
      if(!mo) return 0;
      const ms = monthStartUTC(mo.y, mo.m0);
      const me = monthEndUTCExclusive(mo.y, mo.m0);
      const totalNightsMonth = daysBetweenUTC(ms, me);
      const occ = hm.get(monthKey) || 0;
      return totalNightsMonth > 0 ? (occ / totalNightsMonth) * 100 : 0;
    }
    function avgPct(house){
      let num=0, den=0;
      const hm = map.get(house) || new Map();
      for(const mo of months){
        if(!avgKeys.has(mo.key)) continue;
        const ms = monthStartUTC(mo.y, mo.m0);
        const me = monthEndUTCExclusive(mo.y, mo.m0);
        const totalNightsMonth = daysBetweenUTC(ms, me);
        den += totalNightsMonth;
        num += (hm.get(mo.key) || 0);
      }
      return den>0 ? (num/den)*100 : 0;
    }

    // Sort houses by selected column
    const housesToShow = [...housesToShow0].sort((a,b)=>{
      const k = occSort.key;
      const mult = (occSort.dir === "asc") ? 1 : -1;
      if(k === "HouseName"){
        return a.localeCompare(b) * mult;
      }
      if(k === "AVG"){
        return (avgPct(a)-avgPct(b)) * mult;
      }
      // month key
      return (pctFor(a,k) - pctFor(b,k)) * mult;
    });

    // Header
    const trh = document.createElement("tr");
    trh.innerHTML = `
      <th class="houseCol sortable" data-key="HouseName">HouseName</th>
      ${months.map(mo => `<th class="sortable" data-key="${escapeHtml(mo.key)}">${escapeHtml(mo.key)}</th>`).join("")}
      <th class="sortable" data-key="AVG">Promedio</th>
    `;
    thead.appendChild(trh);

    // bind sort handlers for occupancy table (headers rebuilt each render)
    (function bindOccSort(){
      const ths = thead.querySelectorAll("th.sortable");
      ths.forEach(th=>{
        th.addEventListener("click", ()=>{
          const key = th.getAttribute("data-key");
          if(!key) return;
          if(occSort.key === key){
            occSort.dir = (occSort.dir === "asc") ? "desc" : "asc";
          }else{
            occSort.key = key;
            occSort.dir = (key === "HouseName") ? "asc" : "desc";
          }
          ths.forEach(x=>x.removeAttribute("data-dir"));
          th.setAttribute("data-dir", occSort.dir);
          renderOccupancyByMonth();
        });
      });
      const th0 = thead.querySelector(`th.sortable[data-key="${occSort.key}"]`);
      if(th0) th0.setAttribute("data-dir", occSort.dir);
    })();
;

    // Body
    const frag = document.createDocumentFragment();
    for(const house of housesToShow){
      const tr = document.createElement("tr");
      const hm = map.get(house) || new Map();

      const rowCells = months.map(mo=>{
        const ms = monthStartUTC(mo.y, mo.m0);
        const me = monthEndUTCExclusive(mo.y, mo.m0);
        const totalNightsMonth = daysBetweenUTC(ms, me);

        const occ = hm.get(mo.key) || 0;
        const pct = totalNightsMonth > 0 ? (occ / totalNightsMonth) * 100 : 0;

        const pctTxt = `${pct.toFixed(0)}%`;
        const occTxt = `${occ}/${totalNightsMonth} noches`;

        return `
          <td class="occCell">
            <div class="occTop">
              <span class="mono">${escapeHtml(occTxt)}</span>
              <span class="mono">${escapeHtml(pctTxt)}</span>
            </div>
            <div class="occMain">
              <div class="bar" title="${escapeHtml(pctTxt)}">
                <div style="width:${Math.max(0, Math.min(100, pct)).toFixed(1)}%"></div>
              </div>
            </div>
          </td>
        `;
      }).join("");

      const avg = avgPct(house);
      const avgTxt = `${avg.toFixed(0)}%`;
      tr.innerHTML = `<td class="houseCol">${escapeHtml(house)}</td>${rowCells}<td class="mono">${escapeHtml(avgTxt)}</td>`;
      frag.appendChild(tr);
    }
    tbody.appendChild(frag);

    $("occMeta").textContent =
      `Reservas únicas usadas: ${bookings.size.toLocaleString("es-MX")} · Alojamientos mostrados: ${housesToShow.length.toLocaleString("es-MX")} · Meses: ${months.length}`;

    // Build series for line chart using housesToShow
    buildOccupancySeriesForChart(months, housesToShow, map);
    renderOccLineChart();
    syncOccView();
  }

  function buildOccupancySeriesForChart(months, houses, mapHouseMonth){
    const pctByHouse = new Map();
    for(const house of houses){
      const arr = [];
      const hm = mapHouseMonth.get(house) || new Map();
      for(const mo of months){
        const ms = monthStartUTC(mo.y, mo.m0);
        const me = monthEndUTCExclusive(mo.y, mo.m0);
        const totalNightsMonth = daysBetweenUTC(ms, me);
        const occ = hm.get(mo.key) || 0;
        const pct = totalNightsMonth > 0 ? (occ / totalNightsMonth) * 100 : 0;
        arr.push(+pct.toFixed(2));
      }
      pctByHouse.set(house, arr);
    }
    occSeries = { months: months.map(m=>m.key), houses:[...houses], pctByHouse };
  }

  function renderOccLineChart(){
    const canvas = $("occLineChart");
    if(!canvas){
      if(chOccLines){ chOccLines.destroy(); chOccLines = null; }
      return;
    }
    if(!occSeries){
      if(chOccLines){ chOccLines.destroy(); chOccLines = null; }
      return;
    }

    const labels = occSeries.months;
    const datasets = occSeries.houses.map(h=>{
      const data = occSeries.pctByHouse.get(h) || labels.map(()=>0);
      return { label:h, data, tension:0.25, pointRadius:0, borderWidth:1 };
    });

    if(chOccLines) chOccLines.destroy();
    chOccLines = new Chart(canvas, {
      type: "line",
      data: { labels, datasets },
      options: {
        responsive:true,
        maintainAspectRatio:false,
        interaction:{ mode:"nearest", intersect:false },
        plugins:{
          legend:{ display:true, position:"bottom", labels:{ boxWidth:10 } },
          tooltip:{ callbacks:{ label:(ctx)=>` ${ctx.dataset.label}: ${ctx.raw}%` } }
        },
        scales:{
          y:{ beginAtZero:true, max:100, ticks:{ callback:(v)=>`${v}%` } }
        }
      }
    });
  }

  function syncOccView(){
    const view = $("occView")?.value || "table";
    const lineWrap = $("occLineWrap");
    const tableWrap = $("occTableWrap");
    if(!lineWrap || !tableWrap) return;

    if(view === "line"){
      lineWrap.style.display = "";
      tableWrap.style.display = "none";
    }else{
      lineWrap.style.display = "none";
      tableWrap.style.display = "";
    }
  }

  function downloadCSV(){
    const url = `${API_BASE}/api/otc.csv?${qs()}`;
    window.location.href = url;
  }

  function setDefaultDates(){
    // ✅ 1 de enero de 2025 → hoy
    const today = new Date();
    const pad = (x)=>String(x).padStart(2,"0");
    const ymdLocal = (d)=>`${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;

    const d1 = new Date(2025, 0, 1); // local
    $("from").value = ymdLocal(d1);
    $("to").value = ymdLocal(today);
  }

  (function init(){
    $("baseUrl").textContent = API_BASE || "same-origin";
    setDefaultDates();

    // init multi-comboboxes
    initMCB("mcbPropiedad", { emptyLabel:"Todas", onChange: ()=> applyLocalFilters() });
    initMCB("mcbOccPropiedad", { emptyLabel:"Todas", onChange: ()=> renderOccupancyByMonth() });
    initMCB("mcbOccHouses", { emptyLabel:"Todos", onChange: ()=> renderOccupancyByMonth() });
    initMCB("mcbOccAvgMonths", { emptyLabel:"Todos", onChange: ()=> renderOccupancyByMonth() });

    // botones header
    $("btnReload").addEventListener("click", async ()=>{
      try{ await fetchOTC(); }
      catch(e){ setStatus("err","Error"); alert(String(e.message || e)); }
    });
    $("btnCsv").addEventListener("click", downloadCSV);
    $("btnDebug").addEventListener("click", loadDebug);

    // Tabla OTC: toggle agregado
    $("btnAgg").addEventListener("click", ()=>{
      otcAggMode = !otcAggMode;
      $("btnAgg").textContent = otcAggMode ? "Ver line items" : "Ver montos agregados";
      renderTable();
    });

    // Resumen por huésped
    $("guestSearch")?.addEventListener("input", ()=>{
      // si el usuario escribe, limpiamos select para priorizar el texto
      if($("guestSelect")) $("guestSelect").value = "";
      renderGuestSummary();
    });
    $("guestSelect")?.addEventListener("change", ()=>{
      // si el usuario elige, dejamos el search tal cual, pero manda render
      renderGuestSummary();
    });

    
    // Sort: Tabla OTC (click en encabezados)
    (function bindOTCSort(){
      const table = $("tbody")?.closest("table");
      if(!table) return;
      const ths = table.querySelectorAll("thead th.sortable");
      ths.forEach(th=>{
        th.addEventListener("click", ()=>{
          const key = th.getAttribute("data-key");
          if(!key) return;
          if(otcSort.key === key){
            otcSort.dir = (otcSort.dir === "asc") ? "desc" : "asc";
          }else{
            otcSort.key = key;
            otcSort.dir = "asc";
          }
          ths.forEach(x=>x.removeAttribute("data-dir"));
          th.setAttribute("data-dir", otcSort.dir);
          renderTable();
        });
      });
      // default indicator
      const th0 = table.querySelector(`thead th.sortable[data-key="${otcSort.key}"]`);
      if(th0) th0.setAttribute("data-dir", otcSort.dir);
    })();

    // filtros instantáneos: cuando cambias fechas, se hace fetch inmediato (porque cambia el universo)
    // debounce para no spamear el backend
    let tFetch = null;
    function scheduleFetch(){
      clearTimeout(tFetch);
      tFetch = setTimeout(()=>{
        fetchOTC().catch(e=>{ setStatus("err","Error"); alert(String(e.message || e)); });
      }, 250);
    }

    ["from","to"].forEach(id=>{
      $(id).addEventListener("change", scheduleFetch);
      $(id).addEventListener("input", scheduleFetch);
    });

    // filtros locales (no requieren fetch)
    ["q","selSource","selStatus"].forEach(id=>{
      $(id).addEventListener("input", applyLocalFilters);
      $(id).addEventListener("change", applyLocalFilters);
    });

    // vista ocupación
    $("occView").addEventListener("change", syncOccView);

    // ✅ carga inicial automática (ya no necesitas "Cargar")
    fetchOTC().catch(e=>{
      setStatus("err","Error");
      alert(String(e.message || e));
    });
  })();
</script>
</body>
</html>
