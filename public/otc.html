<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Checkinnreservas · Dashboard OTC</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --panel:#0f1a30; --text:#e8eefc; --muted:#9fb0d0; --line:#1e2b4a;
      --shadow: 0 12px 28px rgba(0,0,0,.35);
      --r:16px; --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--font);
      background:linear-gradient(180deg,#070b15 0%, #0b1220 40%, #070b15 100%);
      color:var(--text);
    }
    header{
      position:sticky; top:0; z-index:60;
      background:rgba(7,11,21,.75); backdrop-filter: blur(10px);
      border-bottom:1px solid var(--line);
    }
    .wrap{max-width:1280px; margin:0 auto; padding:16px 18px;}
    .topbar{display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap}
    .brand{display:flex; align-items:center; gap:10px;}
    .logo{
      width:36px; height:36px; border-radius:12px;
      background: radial-gradient(circle at 30% 30%, #4cc9f0 0%, #4361ee 55%, #3a0ca3 100%);
      box-shadow: 0 10px 20px rgba(67,97,238,.35);
    }
    h1{font-size:16px; margin:0; font-weight:800; letter-spacing:.2px}
    .sub{margin:2px 0 0; color:var(--muted); font-size:12px}
    .actions{display:flex; align-items:center; gap:10px; flex-wrap:wrap}
    button, select, input{
      background:var(--panel); color:var(--text);
      border:1px solid var(--line); border-radius:12px; padding:10px 12px;
      font-size:13px; outline:none;
    }
    button{cursor:pointer}
    button:hover{border-color:#2b3c63}
    button.primary{
      background:linear-gradient(180deg, rgba(76,201,240,.18), rgba(67,97,238,.10));
      border-color:rgba(76,201,240,.35);
    }
    button.ghost{background:transparent}
    .status{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; border-radius:999px;
      background:rgba(11,18,32,.65); border:1px solid var(--line);
      font-size:12px; color:var(--muted);
    }
    .dot{width:8px; height:8px; border-radius:999px; background:#64748b}
    .dot.ok{background:#4ade80}
    .dot.err{background:#fb7185}
    .dot.busy{background:#fbbf24}

    .card{
      background:linear-gradient(180deg, rgba(15,26,48,.98), rgba(11,18,32,.98));
      border:1px solid var(--line);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      overflow:hidden;
      margin-top:14px;
    }
    .hd{
      padding:14px 14px 10px; border-bottom:1px solid var(--line);
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .hd h2{margin:0; font-size:14px; letter-spacing:.2px}
    .hint{margin:3px 0 0; font-size:12px; color:var(--muted)}
    .bd{padding:14px}

    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:end}
    .row > *{flex:1}
    .row .small{flex:.9}
    .row .xsmall{flex:.75}

    .pill{
      display:inline-flex; align-items:center; gap:6px;
      padding:4px 8px; border-radius:999px;
      background:rgba(76,201,240,.10);
      border:1px solid rgba(76,201,240,.22);
      color:var(--text);
      font-size:12px;
      white-space:nowrap;
    }

    .kpis{
      display:grid; gap:10px;
      grid-template-columns: repeat(6, 1fr);
    }
    @media (max-width: 1100px){ .kpis{grid-template-columns:repeat(3,1fr)} }
    @media (max-width: 720px){ .kpis{grid-template-columns:repeat(2,1fr)} }
    @media (max-width: 520px){ .kpis{grid-template-columns:1fr} }

    .kpi{
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(18,31,58,.7), rgba(15,26,48,.55));
      border-radius:16px;
      padding:12px;
      min-height: 88px;
    }
    .kpi .lbl{font-size:12px; color:var(--muted)}
    .kpi .val{margin-top:6px; font-size:18px; font-weight:900; letter-spacing:.3px}
    .kpi .meta{margin-top:6px; font-size:12px; color:var(--muted)}
    .kpi .mini{margin-top:8px; height:110px; width:100%}

    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;}

    .tableWrap{
      border:1px solid var(--line);
      border-radius:14px;
      overflow:hidden;
      background:rgba(18,31,58,.35);
    }
    table{width:100%; border-collapse:collapse; font-size:12.5px}
    thead{
      position:sticky; top:0;
      background:rgba(11,18,32,.95);
      z-index:5;
    }
    th, td{
      padding:10px 10px;
      border-bottom:1px solid rgba(30,43,74,.75);
      vertical-align:top;
      text-align:left;
      white-space:nowrap;
    }
    tbody tr:hover{background:rgba(76,201,240,.06)}
    .scrollY{max-height: 560px; overflow:auto;}
    .footer{padding:14px 18px; color:var(--muted); font-size:12px; border-top:1px solid var(--line);}

    /* ======= OCUPACIÓN: tabla sticky header + sticky first col ======= */
    .occScroll{ max-height: 520px; overflow: auto; }
    #occTable{
      width:100%;
      border-collapse: separate;
      border-spacing: 0;
      font-size:12.5px;
    }
    #occTable th, #occTable td{
      padding:10px 10px;
      border-bottom:1px solid rgba(30,43,74,.75);
      white-space: nowrap;
    }
    #occTable thead th{
      position: sticky; top: 0; z-index: 7;
      background: rgba(11,18,32,.98);
      border-bottom: 1px solid rgba(30,43,74,.75);
    }
    #occTable .houseCol{
      position: sticky; left: 0; z-index: 6;
      background: rgba(11,18,32,.98);
      border-right: 1px solid rgba(30,43,74,.75);
      font-weight: 800;
    }
    #occTable thead th.houseCol{ z-index: 10; }

    .occCell{ min-width: 210px; white-space: normal; line-height: 1.25; }
    .occTop{ display:flex; justify-content:space-between; gap:10px; font-size:12px; color:var(--muted); }
    .occMain{ margin-top:6px; display:flex; align-items:center; gap:10px; }
    .bar{
      flex:1; height:10px; border-radius:999px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .bar > div{
      height:100%;
      width:0%;
      background:linear-gradient(90deg, rgba(76,201,240,.9), rgba(67,97,238,.9));
    }
    #occLineWrap{ overflow:hidden; }

    /* ======= Multi-combobox (dropdown con checks) ======= */
    .mcb{
      position:relative;
      min-width: 220px;
    }
    .mcbBtn{
      width:100%;
      text-align:left;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .mcbBtn span{
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      color: var(--text);
    }
    .mcbBtn .caret{
      opacity:.8;
      font-size:12px;
      margin-left:8px;
    }
    .mcbPanel{
      position:absolute;
      top: calc(100% + 8px);
      left: 0;
      right: 0;
      z-index: 80;
      background: rgba(11,18,32,.98);
      border:1px solid var(--line);
      border-radius:14px;
      box-shadow: var(--shadow);
      padding:10px;
      display:none;
    }
    .mcb.open .mcbPanel{ display:block; }
    .mcbSearch{
      width:100%;
      margin-bottom:10px;
      padding:10px 12px;
      border-radius:12px;
    }
    .mcbTools{
      display:flex;
      gap:8px;
      margin-bottom:10px;
      flex-wrap:wrap;
    }
    .mcbTools button{
      padding:8px 10px;
      border-radius:12px;
      font-size:12px;
    }
    .mcbList{
      max-height: 240px;
      overflow:auto;
      border:1px solid rgba(30,43,74,.75);
      border-radius:12px;
      background: rgba(18,31,58,.25);
    }
    .mcbItem{
      display:flex;
      gap:10px;
      align-items:flex-start;
      padding:9px 10px;
      border-bottom:1px solid rgba(30,43,74,.55);
    }
    .mcbItem:last-child{ border-bottom:none; }
    .mcbItem:hover{ background: rgba(76,201,240,.06); }
    .mcbItem label{
      display:flex;
      gap:10px;
      align-items:flex-start;
      width:100%;
      cursor:pointer;
      white-space:normal;
      line-height:1.2;
      font-size:12.5px;
    }
    .mcbItem input{ margin-top:2px; }
    .mcbFooter{
      margin-top:10px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      color:var(--muted);
      font-size:12px;
    }
  
    /* ======= Guest summary ======= */
    .guestRow{display:flex; gap:10px; flex-wrap:wrap; align-items:end}
    .guestRow > *{flex:1}
    .guestMatches{
      display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;
    }
    .guestChip{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(76,201,240,.22);
      background:rgba(76,201,240,.08);
      cursor:pointer;
      font-size:12.5px;
      color:var(--text);
      max-width: 100%;
    }
    .guestChip.active{
      border-color: rgba(76,201,240,.45);
      background: rgba(76,201,240,.14);
      box-shadow: 0 10px 20px rgba(76,201,240,.10);
    }
    .guestChip .mono{opacity:.9}
    .stars{letter-spacing:1px}

</style>
</head>

<body>
<header>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <h1>Checkinnreservas · Dashboard OTC</h1>
          <div class="sub">Backend: Cloud Run · <span class="mono" id="baseUrl">same-origin</span></div>
        </div>
      </div>

      <div class="actions">
        <span id="apiStatus" class="status"><span class="dot busy"></span><span>Listo</span></span>
        <!-- Cargar ya no es necesario, lo dejamos como "Recargar" por si quieres forzar fetch -->
        <button id="btnReload" class="primary">Recargar datos</button>
        <button id="btnCsv">Descargar CSV</button>
        <button id="btnDebug" class="ghost">Debug</button>
      </div>
    </div>
  </div>
</header>

<main class="wrap">

  <!-- Parámetros -->
  <section class="card" style="overflow:visible;">
    <div class="hd">
      <div>
        <h2>Parámetros</h2>
        <div class="hint">
          API: <span class="mono">/api/otc</span> y <span class="mono">/api/otc.csv</span> · Fechas incluyen overlap.
          Los filtros aplican al instante.
        </div>
      </div>
      <div class="hint" id="metaLine">—</div>
    </div>

    <div class="bd">
      <div class="row">
        <label style="flex:1">
          <div class="hint">Desde</div>
          <input id="from" type="date" />
        </label>
        <label style="flex:1">
          <div class="hint">Hasta</div>
          <input id="to" type="date" />
        </label>

        <label class="small">
          <div class="hint">Buscar</div>
          <input id="q" placeholder="Guest / House / Id / Source / LineItem..." />
        </label>

        <!-- ✅ combobox multi: Propiedad -->
        <div class="mcb" id="mcbPropiedad" style="flex:1.2">
          <div class="hint">Propiedad</div>
          <button class="mcbBtn" type="button">
            <span class="mcbLabel">Todas</span>
            <span class="caret">▾</span>
          </button>
          <div class="mcbPanel">
            <input class="mcbSearch" type="text" placeholder="Buscar propiedad..." />
            <div class="mcbTools">
              <button type="button" class="mcbAll">Seleccionar todo</button>
              <button type="button" class="mcbNone">Limpiar</button>
            </div>
            <div class="mcbList"></div>
            <div class="mcbFooter">
              <span class="mcbCount">0 seleccionados</span>
              <button type="button" class="mcbClose">Cerrar</button>
            </div>
          </div>
        </div>

        <label class="xsmall">
          <div class="hint">Source</div>
          <select id="selSource">
            <option value="">Todos</option>
          </select>
        </label>

        <label class="xsmall">
          <div class="hint">Status</div>
          <select id="selStatus">
            <option value="">Todos</option>
          </select>
        </label>
      </div>

      <div class="hint" style="margin-top:10px">
        Tip: “Propiedad” es multiselección con checks. Si no seleccionas nada, se asume “todas”.
      </div>
    </div>
  </section>

  <!-- KPIs + mini charts por monto -->
  <section class="card">
    <div class="hd">
      <div>
        <h2>KPIs</h2>
        <div class="hint">Montos por LineItem + gráficas por <b>monto</b> (sum GrossAmount). Incluye etiquetas en barras.</div>
      </div>
      <div class="hint"><span class="pill" id="pillFiltered">0 filas</span></div>
    </div>

    <div class="bd">
      <div class="kpis">
        <div class="kpi">
          <div class="lbl">Reservas únicas</div>
          <div class="val" id="kpiBookings">—</div>
          <div class="meta">IDs distintos</div>
        </div>

        <div class="kpi">
          <div class="lbl">Noches (sum)</div>
          <div class="val" id="kpiNights">—</div>
          <div class="meta">Suma Nights</div>
        </div>

        <div class="kpi">
          <div class="lbl">Gross (sum)</div>
          <div class="val" id="kpiGross">—</div>
          <div class="meta">Suma GrossAmount</div>
        </div>

        <div class="kpi">
          <div class="lbl">RoomRate (sum)</div>
          <div class="val" id="kpiRoomRate">—</div>
          <div class="meta">LineItem = RoomRate</div>
        </div>

        <div class="kpi">
          <div class="lbl">Fee (sum)</div>
          <div class="val" id="kpiFee">—</div>
          <div class="meta">LineItem = Fee</div>
        </div>

        <div class="kpi">
          <div class="lbl">Tax (sum)</div>
          <div class="val" id="kpiTax">—</div>
          <div class="meta">LineItem = Tax</div>
        </div>

        <div class="kpi" style="grid-column: span 3;">
          <div class="lbl">Monto por Source</div>
          <div class="meta">Barras (sum GrossAmount, top 12) + etiquetas</div>
          <div class="mini"><canvas id="chSourceBar"></canvas></div>
        </div>

        <div class="kpi" style="grid-column: span 3;">
          <div class="lbl">Monto por Status</div>
          <div class="meta">Barras (sum GrossAmount, top 12) + etiquetas</div>
          <div class="mini"><canvas id="chStatusBar"></canvas></div>
        </div>
      </div>
    </div>
  </section>

  <!-- Ocupación -->
  <section class="card">
    <div class="hd">
      <div>
        <h2>Ocupación por alojamiento (por mes)</h2>
        <div class="hint">
          Se calcula con Arrival–Departure, deduplicando por <span class="mono">Id</span>.
          Vista tabla o líneas. Los filtros son combobox multiselección con checks.
        </div>
      </div>
      <div class="hint" id="occMeta">—</div>
    </div>

    <div class="bd">
      <div class="row" style="margin-bottom:10px">
        <label class="small">
          <div class="hint">Vista</div>
          <select id="occView">
            <option value="table">Tabla</option>
            <option value="line">Gráfica de líneas (% ocupación)</option>
          </select>
        </label>

        
        <div class="mcb" id="mcbOccAvgMonths" style="flex:1.2">
          <div class="hint">Promedio (mes-año)</div>
          <button class="mcbBtn" type="button">
            <span class="mcbLabel">Todos</span>
            <span class="caret">▾</span>
          </button>
          <div class="mcbPanel">
            <input class="mcbSearch" type="text" placeholder="Buscar mes..." />
            <div class="mcbTools">
              <button type="button" class="mcbAll">Seleccionar todo</button>
              <button type="button" class="mcbNone">Limpiar</button>
            </div>
            <div class="mcbList"></div>
            <div class="mcbFooter">
              <span class="mcbCount">0 seleccionados</span>
              <button type="button" class="mcbClose">Cerrar</button>
            </div>
          </div>
        </div>


        <!-- ✅ combobox multi: Propiedad (ocupación) -->
        <div class="mcb" id="mcbOccPropiedad" style="flex:1.2">
          <div class="hint">Propiedad</div>
          <button class="mcbBtn" type="button">
            <span class="mcbLabel">Todas</span>
            <span class="caret">▾</span>
          </button>
          <div class="mcbPanel">
            <input class="mcbSearch" type="text" placeholder="Buscar propiedad..." />
            <div class="mcbTools">
              <button type="button" class="mcbAll">Seleccionar todo</button>
              <button type="button" class="mcbNone">Limpiar</button>
            </div>
            <div class="mcbList"></div>
            <div class="mcbFooter">
              <span class="mcbCount">0 seleccionados</span>
              <button type="button" class="mcbClose">Cerrar</button>
            </div>
          </div>
        </div>

        <!-- ✅ combobox multi: Alojamientos -->
        <div class="mcb" id="mcbOccHouses" style="flex:2">
          <div class="hint">Alojamientos (HouseName)</div>
          <button class="mcbBtn" type="button">
            <span class="mcbLabel">Todos</span>
            <span class="caret">▾</span>
          </button>
          <div class="mcbPanel">
            <input class="mcbSearch" type="text" placeholder="Buscar alojamiento..." />
            <div class="mcbTools">
              <button type="button" class="mcbAll">Seleccionar todo</button>
              <button type="button" class="mcbNone">Limpiar</button>
            </div>
            <div class="mcbList"></div>
            <div class="mcbFooter">
              <span class="mcbCount">0 seleccionados</span>
              <button type="button" class="mcbClose">Cerrar</button>
            </div>
          </div>
        </div>

        <div class="hint" style="flex:2; align-self:end">
          Tip: si no seleccionas nada, se asume “todos”.
        </div>
      </div>

      <!-- Line chart -->
      <div id="occLineWrap" class="tableWrap" style="display:none;">
        <div style="height:420px; padding:10px;">
          <canvas id="occLineChart"></canvas>
        </div>
      </div>

      <!-- Table -->
      <div id="occTableWrap" class="tableWrap">
        <div class="occScroll">
          <table id="occTable">
            <thead id="occThead"></thead>
            <tbody id="occTbody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </section>


  <!-- Resumen por huésped -->
  <section class="card">
    <div class="hd">
      <div>
        <h2>Resumen por huésped</h2>
        <div class="hint">
          Filtra por <b>nombre</b> o <b>teléfono</b>. Se calcula con las filas ya filtradas por los parámetros actuales.
          La clasificación (★) se basa en cantidad de reservas, monto y recurrencia.
        </div>
      </div>
      <div class="hint" id="guestMeta">—</div>
    </div>

    <div class="bd">
      <div class="guestRow">
        <label style="flex:1.6">
          <div class="hint">Seleccionar huésped (combo con búsqueda)</div>
          <input id="guestCombo" list="guestList" placeholder="Escribe nombre o teléfono (sin acentos / mayúsculas)…" />
          <datalist id="guestList"></datalist>
          <div class="hint" style="margin-top:6px">Tip: puedes escribir parcial. Se hace coincidencia “inteligente” (sin acentos, sin mayúsculas, y tolerante a nombres parecidos).</div>
        </label>
        <label class="small">
          <div class="hint">Sugerencias similares</div>
          <div class="hint">Da click en un chip para ver detalle</div>
        </label>
      </div>

      <div class="guestMatches" id="guestMatches"></div>

      <div class="hint" id="guestNoData" style="display:none; margin-top:10px">No se detectaron huéspedes para los filtros actuales.</div>

      <div class="kpis" style="margin-top:12px">
        <div class="kpi">
          <div class="lbl">Reservas (IDs únicos)</div>
          <div class="val" id="g_kpiBookings">—</div>
          <div class="meta">Cantidad total de estancias detectadas</div>
        </div>

        <div class="kpi">
          <div class="lbl">Monto pagado (sum Gross)</div>
          <div class="val" id="g_kpiGross">—</div>
          <div class="meta">Suma GrossAmount (todas las líneas)</div>
        </div>

        <div class="kpi">
          <div class="lbl">Alojamientos donde se hospedó</div>
          <div class="val" id="g_kpiHouses">—</div>
          <div class="meta">HouseName distintos</div>
        </div>

        <div class="kpi">
          <div class="lbl">Clasificación</div>
          <div class="val" id="g_kpiStars">—</div>
          <div class="meta" id="g_kpiExplain">—</div>
        </div>

        <div class="kpi" style="grid-column: span 6;">
          <div class="lbl">Resumen por Source</div>
          <div class="meta">Reservas (IDs) y monto por canal</div>
          <div class="tableWrap" style="margin-top:10px">
            <div class="scrollY" style="max-height:260px">
              <table>
                <thead>
                  <tr>
                    <th>Source</th>
                    <th>Reservas (IDs)</th>
                    <th>Monto (Gross)</th>
                  </tr>
                </thead>
                <tbody id="guestSourceTbody"></tbody>
              </table>
            </div>
          </div>
        </div>

        <div class="kpi" style="grid-column: span 6;">
          <div class="lbl">Metodología de “huésped importante”</div>
          <div class="meta" style="white-space:normal; line-height:1.4; margin-top:8px">
            <b>Puntaje 0–100</b> = Reservas (0–40) + Monto (0–40) + Recurrencia (0–20).<br/>
            • <b>Reservas</b>: 8 pts por reserva (máx 40).<br/>
            • <b>Monto</b>: escala logarítmica (máx 40) para no “castigar” valores muy altos.<br/>
            • <b>Recurrencia</b>: 5 pts por mes distinto con estancia (máx 20).<br/>
            <b>Estrellas</b>: 1★ (0–19), 2★ (20–39), 3★ (40–59), 4★ (60–79), 5★ (80–100).<br/>
            Se marca como <b>huésped importante</b> cuando obtiene <b>5★</b>.
          </div>
        </div>
      </div>
    </div>
  </section>


  <!-- Tabla OTC -->
  <section class="card">
    <div class="hd">
      <div>
        <h2>Tabla OTC</h2>
        <div class="hint">Tabla + filtros instantáneos + overlap por fechas</div>
      </div>
    </div>

    <div class="bd">
      <div class="tableWrap">
        <div class="scrollY">
          <table>
            <thead>
              <tr>
                <th>Id</th>
                <th>Propiedad</th>
                <th>Source</th>
                <th>Status</th>
                <th>Arrival</th>
                <th>Departure</th>
                <th>Nights</th>
                <th>HouseName</th>
                <th>GuestName</th>
                <th>GuestEmail</th>
                <th>GuestPhone</th>
                <th>GuestCountryCode</th>
                <th>LineItem</th>
                <th>GrossAmount</th>
                <th>Currency</th>
              </tr>
            </thead>
            <tbody id="tbody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="footer">
      Export CSV usa: <span class="mono">/api/otc.csv</span>
    </div>
  </section>

</main>

<script>
  // Si abres desde GitHub Pages, define aquí tu Cloud Run:
  // const API_BASE = "https://checkinnreservas-1044570371371.northamerica-south1.run.app";
  const API_BASE = "";

  let rowsRaw = [];
  let rowsFiltered = [];

  // Guest summary state
  let guestSelectedKey = null;
  let guestScores = new Map();

  // Charts
  let chSourceBar = null;
  let chStatusBar = null;
  let chOccLines = null;

  // Ocupación series cache
  let occSeries = null; // { months:[...], houses:[...], pctByHouse: Map(house -> [pct...]) }

  // Multi-combobox state: id -> {items:[...], selected:Set, onChange(fn), labelEl, listEl, searchEl, countEl}
  const mcb = new Map();

  const $ = (id) => document.getElementById(id);

  function setStatus(kind, text){
    const el = $("apiStatus");
    const dot = el.querySelector(".dot");
    dot.classList.remove("ok","err","busy");
    dot.classList.add(kind);
    el.lastElementChild.textContent = text;
  }

  function moneyMXN(v){
    const n = Number(v);
    if(!Number.isFinite(n)) return "—";
    try{ return new Intl.NumberFormat("es-MX",{style:"currency",currency:"MXN"}).format(n); }
    catch{ return "$" + n.toFixed(2); }
  }

  function safeStr(v){ return (v === null || v === undefined) ? "" : String(v); }
  function safeNum(v){ const n = Number(v); return Number.isFinite(n) ? n : 0; }

  // ===== Propiedad derivada de HouseName =====
  function propertyFromHouse(house){
    let s = safeStr(house).trim();
    if(!s) return "—";
    s = s.replace(/\s*\([^)]*\)\s*$/g, "").trim();        // quita paréntesis final
    if (s.includes("#")) s = s.split("#")[0].trim();      // corta en #
    s = s.split(" - ")[0].split(" – ")[0].trim();         // cortes extra
    s = s.replace(/\s{2,}/g, " ").trim();
    return s || "—";
  }

  // Arrival/Departure vienen como "MM/DD/YYYY"
  function parseMMDDYYYY(s){
    const t = safeStr(s).trim();
    if(!t) return null;
    const m = t.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if(!m) return null;
    const mm = Number(m[1]), dd = Number(m[2]), yyyy = Number(m[3]);
    if(!mm || !dd || !yyyy) return null;
    return new Date(Date.UTC(yyyy, mm-1, dd, 0, 0, 0));
  }
  function parseISODateInput(s){
    const t = safeStr(s).trim();
    if(!t) return null;
    const m = t.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if(!m) return null;
    const yyyy = Number(m[1]), mm = Number(m[2]), dd = Number(m[3]);
    return new Date(Date.UTC(yyyy, mm-1, dd, 0, 0, 0));
  }

  // overlap: [aStart, aEnd) toca [bStart, bEnd) si aStart < bEnd && bStart < aEnd
  function overlaps(arrivalMMDD, departureMMDD, fromISO, toISO){
    const aStart = parseMMDDYYYY(arrivalMMDD);
    const aEnd   = parseMMDDYYYY(departureMMDD);
    const bStart = parseISODateInput(fromISO);
    const bEnd   = parseISODateInput(toISO);
    if(!aStart || !aEnd || !bStart || !bEnd) return true;

    const bEndEx = new Date(bEnd.getTime());
    bEndEx.setUTCDate(bEndEx.getUTCDate() + 1); // end exclusivo (to inclusive)
    return (aStart < bEndEx) && (bStart < aEnd);
  }

  function qs(){
    const from = $("from").value;
    const to = $("to").value;
    return new URLSearchParams({ from, to }).toString();
  }

  function normalizeRow(r){
    const house = r.HouseName;
    const prop = propertyFromHouse(house);
    return {
      Id: r.Id,
      Property: prop,
      Source: r.Source,
      Status: r.Status,
      DateArrival: r.DateArrival,
      DateDeparture: r.DateDeparture,
      Nights: safeNum(r.Nights),
      HouseName: r.HouseName,
      GuestName: r.GuestName,
      GuestEmail: r.GuestEmail,
      GuestPhone: r.GuestPhone,
      GuestCountryCode: r.GuestCountryCode,
      LineItem: r.LineItem,
      GrossAmount: safeNum(r.GrossAmount),
      Currency: r.Currency,
      _raw: r
    };
  }

  async function fetchOTC(){
    setStatus("busy", "Cargando...");
    $("metaLine").textContent = "—";

    const url = `${API_BASE}/api/otc?${qs()}`;
    const res = await fetch(url, { headers: { "Accept":"application/json" } });
    const data = await res.json();

    if(!res.ok || !data?.ok){
      setStatus("err", "Error");
      throw new Error(data?.error || `HTTP ${res.status}`);
    }

    rowsRaw = (data.rows || []).map(normalizeRow);
    setStatus("ok", `OK · ${rowsRaw.length} filas`);

    const metaBits = [
      `bookingsFetched=${data.bookingsFetched ?? "?"}`,
      `pagesUsed=${data.pagesUsed ?? "?"}`,
      `effectivePageSize=${data.effectivePageSize ?? "?"}`,
      `totalCount=${data.totalCount ?? "?"}`
    ];
    $("metaLine").textContent = metaBits.join(" · ");

    rebuildSingleSelects();
    rebuildPropiedadMCBFromRowsRaw();
    applyLocalFilters(); // instant
  }

  async function loadDebug(){
    setStatus("busy", "Debug...");
    const url = `${API_BASE}/api/debug/bookings`;
    const res = await fetch(url, { headers: { "Accept":"application/json" } });
    const data = await res.json();
    if(!res.ok || !data?.ok){
      setStatus("err","Debug error");
      alert(data?.error || `HTTP ${res.status}`);
      return;
    }
    setStatus("ok","Debug OK");
    alert(
      [
        "Debug paginación Lodgify",
        `effectivePageSize: ${data.effectivePageSize}`,
        `pagesUsed: ${data.pagesUsed}`,
        `totalCount: ${data.totalCount}`,
        `bookingsFetched: ${data.bookingsFetched}`,
        `arrivalMin: ${data.arrivalMin}`,
        `arrivalMax: ${data.arrivalMax}`,
      ].join("\n")
    );
  }

  function rebuildSingleSelects(){
    // Source
    const selS = $("selSource");
    const curS = selS.value;
    const sources = [...new Set(rowsRaw.map(r => safeStr(r.Source).trim()).filter(Boolean))]
      .sort((a,b)=>a.localeCompare(b));
    selS.innerHTML = `<option value="">Todos</option>` + sources.map(s => `<option value="${escapeHtml(s)}">${escapeHtml(s)}</option>`).join("");
    selS.value = sources.includes(curS) ? curS : "";

    // Status
    const selSt = $("selStatus");
    const curSt = selSt.value;
    const statuses = [...new Set(rowsRaw.map(r => safeStr(r.Status).trim()).filter(Boolean))]
      .sort((a,b)=>a.localeCompare(b));
    selSt.innerHTML = `<option value="">Todos</option>` + statuses.map(s => `<option value="${escapeHtml(s)}">${escapeHtml(s)}</option>`).join("");
    selSt.value = statuses.includes(curSt) ? curSt : "";
  }

  // ===== Multi-combobox implementation =====
  function initMCB(containerId, { emptyLabel="Todas", onChange=()=>{} }={}){
    const root = $(containerId);
    const btn = root.querySelector(".mcbBtn");
    const labelEl = root.querySelector(".mcbLabel");
    const panel = root.querySelector(".mcbPanel");
    const listEl = root.querySelector(".mcbList");
    const searchEl = root.querySelector(".mcbSearch");
    const countEl = root.querySelector(".mcbCount");
    const btnAll = root.querySelector(".mcbAll");
    const btnNone = root.querySelector(".mcbNone");
    const btnClose = root.querySelector(".mcbClose");

    const state = {
      items: [],
      selected: new Set(),
      emptyLabel,
      onChange,
      root, btn, labelEl, panel, listEl, searchEl, countEl
    };
    mcb.set(containerId, state);

    function open(){ root.classList.add("open"); searchEl.focus(); }
    function close(){ root.classList.remove("open"); }

    btn.addEventListener("click", (e)=>{
      e.preventDefault();
      root.classList.contains("open") ? close() : open();
    });

    btnClose.addEventListener("click", (e)=>{ e.preventDefault(); close(); });

    document.addEventListener("click", (e)=>{
      if(!root.contains(e.target)) close();
    });

    searchEl.addEventListener("input", ()=> renderMCB(containerId));

    btnAll.addEventListener("click", (e)=>{
      e.preventDefault();
      state.selected = new Set(state.items);
      updateMCBLabel(containerId);
      renderMCB(containerId);
      state.onChange(getMCBSelected(containerId));
    });

    btnNone.addEventListener("click", (e)=>{
      e.preventDefault();
      state.selected = new Set();
      updateMCBLabel(containerId);
      renderMCB(containerId);
      state.onChange(getMCBSelected(containerId));
    });
  }

  function setMCBItems(containerId, items, keepSelected=true){
    const state = mcb.get(containerId);
    state.items = [...items];
    if(!keepSelected){
      state.selected = new Set();
    } else {
      // limpia selecciones inexistentes
      const next = new Set();
      for(const v of state.selected){
        if(state.items.includes(v)) next.add(v);
      }
      state.selected = next;
    }
    updateMCBLabel(containerId);
    renderMCB(containerId);
  }

  function getMCBSelected(containerId){
    return [...(mcb.get(containerId)?.selected || [])];
  }

  function updateMCBLabel(containerId){
    const state = mcb.get(containerId);
    const n = state.selected.size;
    if(n === 0){
      state.labelEl.textContent = state.emptyLabel;
    } else if (n === 1){
      state.labelEl.textContent = [...state.selected][0];
    } else {
      state.labelEl.textContent = `${n} seleccionados`;
    }
    state.countEl.textContent = `${n} seleccionados`;
  }

  function renderMCB(containerId){
    const state = mcb.get(containerId);
    const q = state.searchEl.value.trim().toLowerCase();

    const filtered = state.items.filter(v => v.toLowerCase().includes(q));
    state.listEl.innerHTML = filtered.map(v=>{
      const checked = state.selected.has(v) ? "checked" : "";
      const id = `${containerId}__${hashId(v)}`;
      return `
        <div class="mcbItem">
          <label for="${id}">
            <input id="${id}" type="checkbox" ${checked} data-value="${escapeHtml(v)}" />
            <span>${escapeHtml(v)}</span>
          </label>
        </div>
      `;
    }).join("") || `<div class="mcbItem"><span class="hint">Sin resultados</span></div>`;

    // listeners a los checks
    state.listEl.querySelectorAll('input[type="checkbox"]').forEach(chk=>{
      chk.addEventListener("change", ()=>{
        const v = chk.getAttribute("data-value");
        const val = unescapeHtml(v);
        if(chk.checked) state.selected.add(val);
        else state.selected.delete(val);
        updateMCBLabel(containerId);
        state.onChange(getMCBSelected(containerId));
      });
    });

    updateMCBLabel(containerId);
  }

  function hashId(s){
    // hash simple para ids
    let h = 0;
    for (let i=0; i<s.length; i++) h = ((h<<5)-h) + s.charCodeAt(i) | 0;
    return String(Math.abs(h));
  }

  function escapeHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }
  

  function normalizePhoneDigits(phone){
    const raw = safeStr(phone).trim();
    if(!raw) return "";
    // Keep digits only for wa.me
    return raw.replace(/\D/g, "");
  }

  function renderWhatsAppPhone(phone){
    const raw = safeStr(phone).trim();
    if(!raw) return "—";
    const digits = normalizePhoneDigits(raw);
    if(!digits) return escapeHtml(raw);
    const href = `https://wa.me/${digits}`;
    return `<a href="${href}" target="_blank" rel="noopener noreferrer">${escapeHtml(raw)}</a>`;
  }


  // ===== Guest summary helpers =====
  function guestKeyFromRow(r){
    const phoneDigits = normalizePhoneDigits(r.GuestPhone);
    if(phoneDigits) return "p:" + phoneDigits;
    const nm = safeStr(r.GuestName).trim().toLowerCase();
    if(nm) return "n:" + nm;
    return "u:unknown";
  }

  function guestDisplayFromKey(key){
    if(!key) return "—";
    if(key.startsWith("p:")) return key.slice(2);
    if(key.startsWith("n:")) return key.slice(2);
    return "—";
  }

  function monthKeyFromMMDDYYYY(s){
    const d = parseMMDDYYYY(s);
    if(!d) return null;
    const y = d.getUTCFullYear();
    const m = String(d.getUTCMonth()+1).padStart(2,"0");
    return `${y}-${m}`;
  }

  function computeGuestScore(stats){
    // stats: {bookingsCount, grossSum, activeMonthsCount}
    const bookingsPts = Math.min(40, stats.bookingsCount * 8);

    const gross = Math.max(0, stats.grossSum || 0);
    // log scale: 0 -> 0, 1k -> ~10, 10k -> ~20, 100k -> ~30, 1M -> ~40 (aprox)
    const grossPts = Math.min(40, Math.log10(gross + 1) * 10);

    const recPts = Math.min(20, stats.activeMonthsCount * 5);

    const score = Math.max(0, Math.min(100, bookingsPts + grossPts + recPts));
    const stars = Math.min(5, Math.max(1, Math.ceil(score / 20)));

    return {
      score,
      stars,
      important: stars >= 5,
      breakdown: { bookingsPts, grossPts, recPts }
    };
  }

  function starsText(n){
    const k = Math.max(0, Math.min(5, Number(n)||0));
    return "★".repeat(k) + "☆".repeat(5-k);
  }

  function buildGuestStats(rows){
    // Dedup bookings by Id per guest for booking count.
    const byKey = new Map();
    // Track seen booking ids per key
    const seenByKey = new Map();

    for(const r of rows){
      const key = guestKeyFromRow(r);

      if(!byKey.has(key)){
        byKey.set(key, {
          key,
          guestName: safeStr(r.GuestName).trim(),
          guestPhone: normalizePhoneDigits(r.GuestPhone),
          guestEmail: safeStr(r.GuestEmail).trim(),
          grossSum: 0,
          houses: new Set(),
          sources: new Map(), // source -> {grossSum, bookingIds:Set}
          months: new Set(),  // distinct months
          bookingIds: new Set()
        });
        seenByKey.set(key, new Set());
      }

      const st = byKey.get(key);
      st.grossSum += safeNum(r.GrossAmount);
      if(r.HouseName) st.houses.add(safeStr(r.HouseName).trim());
      const mk = monthKeyFromMMDDYYYY(r.DateArrival);
      if(mk) st.months.add(mk);

      const src = safeStr(r.Source).trim() || "—";
      if(!st.sources.has(src)){
        st.sources.set(src, { grossSum: 0, bookingIds: new Set() });
      }
      st.sources.get(src).grossSum += safeNum(r.GrossAmount);

      const id = safeStr(r.Id);
      if(id){
        st.bookingIds.add(id);
        st.sources.get(src).bookingIds.add(id);
      }
    }

    // Finalize counts + score
    const out = [];
    for(const st of byKey.values()){
      const bookingsCount = st.bookingIds.size;
      const activeMonthsCount = st.months.size;
      const scoreObj = computeGuestScore({ bookingsCount, grossSum: st.grossSum, activeMonthsCount });

      out.push({
        ...st,
        bookingsCount,
        activeMonthsCount,
        score: scoreObj.score,
        stars: scoreObj.stars,
        important: scoreObj.important,
        scoreBreakdown: scoreObj.breakdown
      });
    }

    // Build score map for quick lookup
    const scoreMap = new Map();
    for(const g of out){
      scoreMap.set(g.key, { stars: g.stars, important: g.important, score: g.score });
    }

    return { guests: out, scoreMap };
  }


  // ---- Guest summary: combobox + fuzzy matching (sin acentos / mayúsculas) ----
  let guestOptionIndex = [];     // [{key,label,norm,nameNorm,phoneDigits,score}]
  let guestLabelToKey = new Map(); // norm(label)->key

  function stripDiacritics(str){
    const s = String(str ?? "");
    // NFD + quitar diacríticos (fallback para navegadores viejos)
    try{
      return s.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    }catch(e){
      return s.replace(/[\u0300-\u036f]/g, "");
    }
  }

  function normText(str){
    return stripDiacritics(String(str ?? ""))
      .toLowerCase()
      .replace(/\s+/g," ")
      .trim();
  }

  function digitsOnly(str){
    return String(str ?? "").replace(/\D/g,"");
  }

  function bigramSet(s){
    const out = new Set();
    const t = ` ${s} `;
    for(let i=0;i<t.length-1;i++){
      out.add(t.slice(i,i+2));
    }
    return out;
  }

  function fuzzyScore(queryNorm, targetNorm){
    if(!queryNorm) return 0;
    if(!targetNorm) return 0;

    // match directo por inclusión
    const idx = targetNorm.indexOf(queryNorm);
    if(idx >= 0){
      // más alto si aparece al inicio
      const bias = 1 - Math.min(idx / Math.max(1,targetNorm.length), 0.6);
      return 0.85 + 0.15 * bias;
    }

    // overlap de bigramas (ligero y rápido)
    const q = bigramSet(queryNorm);
    const t = bigramSet(targetNorm);
    let inter = 0;
    q.forEach(bg=>{ if(t.has(bg)) inter++; });
    const denom = Math.max(q.size, t.size, 1);
    return inter / denom; // 0..1
  }

  function rebuildGuestCombo(guests){
    const dl = $("guestList");
    const combo = $("guestCombo");
    const noData = $("guestNoData");

    guestOptionIndex = [];
    guestLabelToKey = new Map();

    if(!dl) return;

    if(!guests || !guests.length){
      dl.innerHTML = "";
      if(combo) combo.value = "";
      if(noData) noData.style.display = "block";
      return;
    } else {
      if(noData) noData.style.display = "none";
    }

    // Orden por score desc para que el autocompletado priorice mejores huéspedes
    const ordered = [...guests].sort((a,b)=> (b.score - a.score) || (b.bookingsCount - a.bookingsCount) || (b.grossSum - a.grossSum));

    dl.innerHTML = ordered.map(g=>{
      const name = g.guestName || "—";
      const phone = g.guestPhone ? ` · ${g.guestPhone}` : "";
      const stars = g.important ? " ⭐" : (g.stars ? ` ${starsText(g.stars)}` : "");
      const label = `${name}${phone}${stars}`.trim();
      const norm = normText(label);
      guestLabelToKey.set(norm, g.key);
      guestOptionIndex.push({
        key: g.key,
        label,
        norm,
        nameNorm: normText(g.guestName),
        phoneDigits: digitsOnly(g.guestPhone),
        score: g.score
      });
      return `<option value="${escapeHtml(label)}"></option>`;
    }).join("");
  }

  function bestGuestKeyFromQuery(qRaw){
    const qNorm = normText(qRaw);
    const qDigits = digitsOnly(qRaw);
    if(!qNorm && !qDigits) return null;

    let best = { key:null, s:-1 };

    for(const opt of guestOptionIndex){
      let s = 0;

      // Teléfono: coincidencia fuerte por dígitos
      if(qDigits && opt.phoneDigits){
        if(opt.phoneDigits.includes(qDigits)) s = Math.max(s, 0.95);
      }

      // Nombre/label: fuzzy sin acentos
      if(qNorm){
        s = Math.max(s, fuzzyScore(qNorm, opt.nameNorm));
        s = Math.max(s, 0.75 * fuzzyScore(qNorm, opt.norm)); // label completo un poco menor
      }

      // desempate por score del huésped (importancia histórica)
      const total = s + 0.000001 * (opt.score || 0);

      if(total > best.s){
        best = { key: opt.key, s: total };
      }
    }

    return best.key;
  }

  function renderGuestSummary(){
    const combo = $("guestCombo");
    const qRaw = combo ? combo.value.trim() : "";

    const meta = $("guestMeta");
    const matchesEl = $("guestMatches");
    const tb = $("guestSourceTbody");

    if(!matchesEl || !tb) return;

    // Build guest stats from current filtered rows
    const { guests, scoreMap } = buildGuestStats(rowsFiltered);
    guestScores = scoreMap;

    // Rebuild datalist each render so siempre represente el estado filtrado actual
    rebuildGuestCombo(guests);

    // Si el usuario escribió algo, elegimos mejor coincidencia (fuzzy)
    if(qRaw){
      const k = bestGuestKeyFromQuery(qRaw);
      if(k) guestSelectedKey = k;
    }

    // Si no hay selección, toma el top por score
    if(!guestSelectedKey){
      const topG = [...guests].sort((a,b)=> (b.score - a.score) || (b.bookingsCount - a.bookingsCount) || (b.grossSum - a.grossSum))[0];
      guestSelectedKey = topG ? topG.key : null;
    } else {
      // si el key ya no existe por filtros, re-selecciona
      if(!guests.some(g=>g.key===guestSelectedKey)){
        const topG = [...guests].sort((a,b)=> (b.score - a.score) || (b.bookingsCount - a.bookingsCount) || (b.grossSum - a.grossSum))[0];
        guestSelectedKey = topG ? topG.key : null;
      }
    }

    // Sugerencias similares: usar query si existe, si no, top score
    const qNorm = normText(qRaw);
    const qDigits = digitsOnly(qRaw);

    const filtered = (qNorm || qDigits)
      ? guests.map(g=>{
          const nameNorm = normText(g.guestName);
          const phoneDigits = digitsOnly(g.guestPhone);
          let s = 0;
          if(qDigits && phoneDigits && phoneDigits.includes(qDigits)) s = Math.max(s, 0.95);
          if(qNorm) s = Math.max(s, fuzzyScore(qNorm, nameNorm));
          return { g, s };
        })
        .filter(x=>x.s > 0.10)
        .sort((a,b)=> (b.s - a.s) || (b.g.score - a.g.score))
        .map(x=>x.g)
      : [...guests].sort((a,b)=> (b.score - a.score) || (b.bookingsCount - a.bookingsCount) || (b.grossSum - a.grossSum));

    const top = filtered.slice(0, 12);

    matchesEl.innerHTML = top.map(g=>{
      const isActive = g.key === guestSelectedKey;
      const label = g.guestName || (g.guestPhone ? `Tel ${g.guestPhone}` : guestDisplayFromKey(g.key));
      const sub = g.guestPhone ? g.guestPhone : "";
      const star = g.important ? "⭐" : "";
      return `
        <div class="guestChip ${isActive ? "active":""}" data-key="${escapeHtml(g.key)}" title="${escapeHtml(label)}">
          <span>${star}${escapeHtml(label || "—")}</span>
          <span class="mono" style="color:var(--muted)">${escapeHtml(sub)}</span>
          <span class="mono" style="color:var(--muted)">${escapeHtml(starsText(g.stars))}</span>
        </div>
      `;
    }).join("") || `<span class="hint">No hay coincidencias para el filtro actual.</span>`;

    matchesEl.querySelectorAll(".guestChip").forEach(ch=>{
      ch.addEventListener("click", ()=>{
        const k = unescapeHtml(ch.getAttribute("data-key"));
        guestSelectedKey = k;
        // sincroniza el combo al label del seleccionado (si existe)
        const opt = guestOptionIndex.find(o=>o.key===k);
        if(combo && opt) combo.value = opt.label;
        renderGuestSummary();
        renderTable();
      });
    });

    const selected = guests.find(g => g.key === guestSelectedKey) || top[0] || null;

    if(!selected){
      $("g_kpiBookings").textContent = "—";
      $("g_kpiGross").textContent = "—";
      $("g_kpiHouses").textContent = "—";
      $("g_kpiStars").textContent = "—";
      $("g_kpiExplain").textContent = "—";
      tb.innerHTML = "";
      if(meta) meta.textContent = `Huéspedes detectados: ${guests.length.toLocaleString("es-MX")}`;
      return;
    }

    if(meta) meta.textContent = `Huéspedes detectados: ${guests.length.toLocaleString("es-MX")} · Seleccionado: ${selected.guestName || selected.guestPhone || guestDisplayFromKey(selected.key)}`;

    $("g_kpiBookings").textContent = selected.bookingsCount.toLocaleString("es-MX");
    $("g_kpiGross").textContent = moneyMXN(selected.grossSum);
    $("g_kpiHouses").textContent = String(selected.houses.size);
    $("g_kpiStars").innerHTML = `<span class="stars">${escapeHtml(starsText(selected.stars))}</span>`;
    const b = selected.scoreBreakdown || {};
    $("g_kpiExplain").textContent = `Score ${Math.round(selected.score)}/100 · Reservas ${Math.round(b.bookingsPts||0)} · Monto ${Math.round(b.grossPts||0)} · Recurrencia ${Math.round(b.recPts||0)}`;

    // Source breakdown table for selected guest
    const sources = [...selected.sources.entries()].map(([src, v])=>({
      src,
      bookings: v.bookingIds.size,
      gross: v.grossSum
    })).sort((a,b)=> (b.gross - a.gross) || (b.bookings - a.bookings) || a.src.localeCompare(b.src));

    tb.innerHTML = sources.map(s=>`
      <tr>
        <td>${escapeHtml(s.src)}</td>
        <td class="mono">${s.bookings.toLocaleString("es-MX")}</td>
        <td class="mono">${moneyMXN(s.gross)}</td>
      </tr>
    `).join("") || `<tr><td colspan="3" class="hint">Sin datos</td></tr>`;
  }
  }

function unescapeHtml(s){
    // solo para nuestros values
    return String(s ?? "")
      .replaceAll("&amp;","&")
      .replaceAll("&lt;","<")
      .replaceAll("&gt;",">")
      .replaceAll("&quot;",'"')
      .replaceAll("&#039;","'");
  }

  function rebuildPropiedadMCBFromRowsRaw(){
    const props = [...new Set(rowsRaw.map(r => safeStr(r.Property).trim()).filter(Boolean))]
      .sort((a,b)=>a.localeCompare(b));
    setMCBItems("mcbPropiedad", props, true);
  }

  // ===== Filters =====
  function applyLocalFilters(){
    const q = $("q").value.trim().toLowerCase();
    const src = $("selSource").value.trim().toLowerCase();
    const st = $("selStatus").value.trim().toLowerCase();
    const fromISO = $("from").value;
    const toISO = $("to").value;

    const propsSelected = getMCBSelected("mcbPropiedad").map(x=>x.toLowerCase());
    const hasPropFilter = propsSelected.length > 0;

    rowsFiltered = rowsRaw.filter(r=>{
      if(fromISO && toISO){
        if(!overlaps(r.DateArrival, r.DateDeparture, fromISO, toISO)) return false;
      }
      if(hasPropFilter){
        const rp = safeStr(r.Property).toLowerCase();
        if(!propsSelected.includes(rp)) return false;
      }
      if(src && safeStr(r.Source).toLowerCase() !== src) return false;
      if(st && safeStr(r.Status).toLowerCase() !== st) return false;

      if(!q) return true;
      const hay = [r.Id,r.Property,r.Source,r.Status,r.HouseName,r.GuestName,r.LineItem,r.Currency].join(" ").toLowerCase();
      return hay.includes(q);
    });

    renderKPIs();
    renderMiniChartsByAmount();
    renderOccupancyByMonth();
    renderGuestSummary();
    renderTable();
  }

  // ===== KPIs =====
  function sumByLineItem(name){
    const key = String(name || "").toLowerCase();
    return rowsFiltered.reduce((acc, r)=>{
      if(safeStr(r.LineItem).toLowerCase() === key) return acc + safeNum(r.GrossAmount);
      return acc;
    }, 0);
  }

  function renderKPIs(){
    $("pillFiltered").textContent = `${rowsFiltered.length.toLocaleString("es-MX")} filas`;

    const uniq = new Set(rowsFiltered.map(r => safeStr(r.Id))).size;
    $("kpiBookings").textContent = uniq.toLocaleString("es-MX");

    const nights = rowsFiltered.reduce((a,r)=>a + safeNum(r.Nights), 0);
    $("kpiNights").textContent = nights.toLocaleString("es-MX");

    const gross = rowsFiltered.reduce((a,r)=>a + safeNum(r.GrossAmount), 0);
    $("kpiGross").textContent = moneyMXN(gross);

    $("kpiRoomRate").textContent = moneyMXN(sumByLineItem("RoomRate"));
    $("kpiFee").textContent      = moneyMXN(sumByLineItem("Fee"));
    $("kpiTax").textContent      = moneyMXN(sumByLineItem("Tax"));
  }

  // ===== Table OTC =====
  function renderTable(){
    const tb = $("tbody");
    tb.innerHTML = "";
    const frag = document.createDocumentFragment();

    for(const r of rowsFiltered){
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="mono">${(guestScores.get(guestKeyFromRow(r))?.important ? "⭐ " : "")}${escapeHtml(safeStr(r.Id) || "—")}</td>
        <td>${escapeHtml(safeStr(r.Property) || "—")}</td>
        <td>${escapeHtml(safeStr(r.Source) || "—")}</td>
        <td>${escapeHtml(safeStr(r.Status) || "—")}</td>
        <td class="mono">${escapeHtml(safeStr(r.DateArrival) || "—")}</td>
        <td class="mono">${escapeHtml(safeStr(r.DateDeparture) || "—")}</td>
        <td class="mono">${safeNum(r.Nights) || 0}</td>
        <td title="${escapeHtml(safeStr(r.HouseName))}">${escapeHtml(safeStr(r.HouseName) || "—")}</td>
        <td title="${escapeHtml(safeStr(r.GuestName))}">${escapeHtml(safeStr(r.GuestName) || "—")}</td>
        <td title="${escapeHtml(safeStr(r.GuestEmail))}">${escapeHtml(safeStr(r.GuestEmail) || "—")}</td>
        <td class="mono" title="${escapeHtml(safeStr(r.GuestPhone))}">${renderWhatsAppPhone(r.GuestPhone)}</td>
        <td class="mono" title="${escapeHtml(safeStr(r.GuestCountryCode))}">${escapeHtml(safeStr(r.GuestCountryCode) || "—")}</td>
        <td>${escapeHtml(safeStr(r.LineItem) || "—")}</td>
        <td class="mono">${moneyMXN(r.GrossAmount)}</td>
        <td class="mono">${escapeHtml(safeStr(r.Currency) || "—")}</td>
      `;
      frag.appendChild(tr);
    }
    tb.appendChild(frag);
  }

  // ===== Mini charts with bar labels =====
  function buildSum(field){
    const m = new Map();
    for(const r of rowsFiltered){
      const k = safeStr(r[field]).trim() || "—";
      m.set(k, (m.get(k) || 0) + safeNum(r.GrossAmount));
    }
    const labels = [...m.keys()].sort((a,b)=> (m.get(b)-m.get(a)));
    const data = labels.map(k => m.get(k));
    return { labels, data };
  }

  // Plugin: etiquetas encima de cada barra (sin librerías extra)
  const barValueLabels = {
    id: "barValueLabels",
    afterDatasetsDraw(chart, args, pluginOptions){
      const { ctx } = chart;
      const fmt = pluginOptions?.format || ((v)=>String(v));
      const offset = pluginOptions?.offset ?? 6;
      const color = pluginOptions?.color || "rgba(232,238,252,.9)";
      const fontSize = pluginOptions?.fontSize || 11;

      ctx.save();
      ctx.fillStyle = color;
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      ctx.font = `${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;

      chart.data.datasets.forEach((dataset, di)=>{
        const meta = chart.getDatasetMeta(di);
        meta.data.forEach((el, i)=>{
          const v = dataset.data[i];
          if(v === null || v === undefined) return;
          const p = el.tooltipPosition();
          ctx.fillText(fmt(v), p.x, p.y - offset);
        });
      });

      ctx.restore();
    }
  };

  function renderMiniChartsByAmount(){
    const src = buildSum("Source");
    const st  = buildSum("Status");

    const srcLabels = src.labels.slice(0,12);
    const srcData   = src.data.slice(0,12);

    const stLabels = st.labels.slice(0,12);
    const stData   = st.data.slice(0,12);

    if(chSourceBar) chSourceBar.destroy();
    if(chStatusBar) chStatusBar.destroy();

    const fmtMoneyShort = (v)=>{
      const n = Number(v)||0;
      // abreviación simple (K/M)
      const abs = Math.abs(n);
      if(abs >= 1_000_000) return (n/1_000_000).toFixed(1) + "M";
      if(abs >= 1_000) return (n/1_000).toFixed(1) + "K";
      return String(Math.round(n));
    };

    chSourceBar = new Chart($("chSourceBar"), {
      type: "bar",
      data: { labels: srcLabels, datasets: [{ label:"Monto", data: srcData }] },
      options: {
        responsive:true,
        maintainAspectRatio:false,
        plugins:{
          legend:{ display:false },
          tooltip:{ enabled:true, callbacks:{ label: (ctx)=> ` ${moneyMXN(ctx.raw)}` } },
          barValueLabels: { format: fmtMoneyShort, offset: 6, fontSize: 11 }
        },
        scales:{ y:{ beginAtZero:true } }
      },
      plugins: [barValueLabels]
    });

    chStatusBar = new Chart($("chStatusBar"), {
      type: "bar",
      data: { labels: stLabels, datasets: [{ label:"Monto", data: stData }] },
      options: {
        responsive:true,
        maintainAspectRatio:false,
        plugins:{
          legend:{ display:false },
          tooltip:{ enabled:true, callbacks:{ label: (ctx)=> ` ${moneyMXN(ctx.raw)}` } },
          barValueLabels: { format: fmtMoneyShort, offset: 6, fontSize: 11 }
        },
        scales:{ y:{ beginAtZero:true } }
      },
      plugins: [barValueLabels]
    });
  }

  // ===== Occupancy helpers =====
  function monthStartUTC(y, m0){ return new Date(Date.UTC(y, m0, 1, 0, 0, 0)); }
  function monthEndUTCExclusive(y, m0){ return new Date(Date.UTC(y, m0+1, 1, 0, 0, 0)); }
  function daysBetweenUTC(a, b){
    const ms = b.getTime() - a.getTime();
    return Math.max(0, Math.round(ms / 86400000));
  }
  function intersectNights(aStart, aEndEx, bStart, bEndEx){
    const s = (aStart > bStart) ? aStart : bStart;
    const e = (aEndEx < bEndEx) ? aEndEx : bEndEx;
    return daysBetweenUTC(s, e);
  }
  function monthsBetween(fromISO, toISO){
    const a = parseISODateInput(fromISO);
    const b = parseISODateInput(toISO);
    if(!a || !b) return [];

    const out = [];
    let y = a.getUTCFullYear();
    let m = a.getUTCMonth();
    const y2 = b.getUTCFullYear();
    const m2 = b.getUTCMonth();

    while (y < y2 || (y === y2 && m <= m2)){
      out.push({ y, m0: m, key: `${y}-${String(m+1).padStart(2,"0")}` });
      m++;
      if(m > 11){ m = 0; y++; }
    }
    return out;
  }

  function rebuildOccMCBsFromContext(availableProps, availableHouses, availableMonths){
    // Propiedad (ocupación)
    setMCBItems("mcbOccPropiedad", availableProps, true);

    // Meses para promedio (ocupación)
    setMCBItems("mcbOccAvgMonths", availableMonths, true);

    // Alojamientos
    setMCBItems("mcbOccHouses", availableHouses, true);
  }

  function renderOccupancyByMonth(){
    const fromISO = $("from").value;
    const toISO = $("to").value;
    const months = monthsBetween(fromISO, toISO);

    const thead = $("occThead");
    const tbody = $("occTbody");
    thead.innerHTML = "";
    tbody.innerHTML = "";

    if(!months.length){
      $("occMeta").textContent = "Selecciona Desde/Hasta para calcular ocupación.";
      occSeries = null;
      renderOccLineChart();
      return;
    }

    // Deduplicar por Id para no contar múltiples line items
    const bookings = new Map(); // id -> {house, property, startUTC, endUTCEx}
    for(const r of rowsFiltered){
      const id = safeStr(r.Id);
      if(!id) continue;
      if(bookings.has(id)) continue;

      const start = parseMMDDYYYY(r.DateArrival);
      const endEx = parseMMDDYYYY(r.DateDeparture);
      const house = safeStr(r.HouseName).trim() || "—";
      const prop  = safeStr(r.Property).trim() || propertyFromHouse(house);

      if(!start || !endEx) continue;
      bookings.set(id, { house, property: prop, start, endEx });
    }

    // nights per house/month
    const map = new Map(); // house -> Map(monthKey -> nights)
    const propertyByHouse = new Map();
    const houseSet = new Set();
    const propSet = new Set();

    for(const b of bookings.values()){
      houseSet.add(b.house);
      propertyByHouse.set(b.house, b.property);
      propSet.add(b.property);

      for(const mo of months){
        const ms = monthStartUTC(mo.y, mo.m0);
        const me = monthEndUTCExclusive(mo.y, mo.m0);
        const n = intersectNights(b.start, b.endEx, ms, me);
        if(n <= 0) continue;

        if(!map.has(b.house)) map.set(b.house, new Map());
        const hm = map.get(b.house);
        hm.set(mo.key, (hm.get(mo.key) || 0) + n);
      }
    }

    // Available props/houses for occupancy filters (según rowsFiltered)
    const availableProps = [...propSet].sort((a,b)=>a.localeCompare(b));
    const availableHousesAll = [...houseSet].sort((a,b)=>a.localeCompare(b));

    // Rebuild occupancy MCBs with available items (keep selected if possible)
    rebuildOccMCBsFromContext(availableProps, availableHousesAll, months.map(m=>m.key));

    // Apply occupancy-local property filter
    const occProps = getMCBSelected("mcbOccPropiedad").map(s=>s.toLowerCase());
    const occHasProp = occProps.length > 0;

    let housesAvailable = availableHousesAll.filter(h=>{
      if(!occHasProp) return true;
      const p = safeStr(propertyByHouse.get(h)).toLowerCase();
      return occProps.includes(p);
    }).sort((a,b)=>a.localeCompare(b));

    // Update houses list to only those matching property selection (keeping selection)
    setMCBItems("mcbOccHouses", housesAvailable, true);

    // Apply occupancy-local house filter
    const occHousesSel = getMCBSelected("mcbOccHouses");
    const occHasHouse = occHousesSel.length > 0;
    const occHouseSet = new Set(occHousesSel);

    const housesToShow = housesAvailable.filter(h => !occHasHouse || occHouseSet.has(h));

    
    // Promedio: meses seleccionados (si no hay selección, usa todos los meses visibles)
    const avgMonthsSel = getMCBSelected("mcbOccAvgMonths");
    const avgMonthKeys = (avgMonthsSel && avgMonthsSel.length) ? avgMonthsSel : months.map(m=>m.key);
    const avgSet = new Set(avgMonthKeys);
    const avgCount = avgSet.size;

    // Header
    const trh = document.createElement("tr");
    trh.innerHTML = `
      <th class="houseCol">HouseName</th>
      ${months.map(mo => `<th>${escapeHtml(mo.key)}</th>`).join("")}
      <th>Promedio (${avgCount} meses)</th>
    `;
    thead.appendChild(trh);

    // Body
    const frag = document.createDocumentFragment();
    for(const house of housesToShow){
      const tr = document.createElement("tr");
      const hm = map.get(house) || new Map();

      const rowCells = months.map(mo=>{
        const ms = monthStartUTC(mo.y, mo.m0);
        const me = monthEndUTCExclusive(mo.y, mo.m0);
        const totalNightsMonth = daysBetweenUTC(ms, me);

        const occ = hm.get(mo.key) || 0;
        const pct = totalNightsMonth > 0 ? (occ / totalNightsMonth) * 100 : 0;

        const pctTxt = `${pct.toFixed(0)}%`;
        const occTxt = `${occ}/${totalNightsMonth} noches`;

        return `
          <td class="occCell">
            <div class="occTop">
              <span class="mono">${escapeHtml(occTxt)}</span>
              <span class="mono">${escapeHtml(pctTxt)}</span>
            </div>
            <div class="occMain">
              <div class="bar" title="${escapeHtml(pctTxt)}">
                <div style="width:${Math.max(0, Math.min(100, pct)).toFixed(1)}%"></div>
              </div>
            </div>
          </td>
        `;
      }).join("");

      // Avg cell (ponderado por noches disponibles en meses seleccionados)
let occSum = 0;
let totalSum = 0;
for(const mo of months){
  if(!avgSet.has(mo.key)) continue;
  const ms = monthStartUTC(mo.y, mo.m0);
  const me = monthEndUTCExclusive(mo.y, mo.m0);
  const totalNightsMonth = daysBetweenUTC(ms, me);
  totalSum += totalNightsMonth;
  occSum += (hm.get(mo.key) || 0);
}
const avgPct = totalSum > 0 ? (occSum / totalSum) * 100 : 0;
const avgPctTxt = `${avgPct.toFixed(0)}%`;
const avgOccTxt = `${occSum}/${totalSum} noches`;
const avgCell = `
  <td class="occCell">
    <div class="occTop">
      <span class="mono">${escapeHtml(avgOccTxt)}</span>
      <span class="mono">${escapeHtml(avgPctTxt)}</span>
    </div>
    <div class="occMain">
      <div class="bar" title="${escapeHtml(avgPctTxt)}">
        <div style="width:${Math.max(0, Math.min(100, avgPct)).toFixed(1)}%"></div>
      </div>
    </div>
  </td>
`;

tr.innerHTML = `<td class="houseCol">${escapeHtml(house)}</td>${rowCells}${avgCell}`;

      frag.appendChild(tr);
    }
    tbody.appendChild(frag);

    $("occMeta").textContent =
      `Reservas únicas usadas: ${bookings.size.toLocaleString("es-MX")} · Alojamientos mostrados: ${housesToShow.length.toLocaleString("es-MX")} · Meses: ${months.length} · Promedio: ${avgCount} meses`;

    // Build series for line chart using housesToShow
    buildOccupancySeriesForChart(months, housesToShow, map);
    renderOccLineChart();
    syncOccView();
  }

  function buildOccupancySeriesForChart(months, houses, mapHouseMonth){
    const pctByHouse = new Map();
    for(const house of houses){
      const arr = [];
      const hm = mapHouseMonth.get(house) || new Map();
      for(const mo of months){
        const ms = monthStartUTC(mo.y, mo.m0);
        const me = monthEndUTCExclusive(mo.y, mo.m0);
        const totalNightsMonth = daysBetweenUTC(ms, me);
        const occ = hm.get(mo.key) || 0;
        const pct = totalNightsMonth > 0 ? (occ / totalNightsMonth) * 100 : 0;
        arr.push(+pct.toFixed(2));
      }
      pctByHouse.set(house, arr);
    }
    occSeries = { months: months.map(m=>m.key), houses:[...houses], pctByHouse };
  }

  function renderOccLineChart(){
    const canvas = $("occLineChart");
    if(!canvas){
      if(chOccLines){ chOccLines.destroy(); chOccLines = null; }
      return;
    }
    if(!occSeries){
      if(chOccLines){ chOccLines.destroy(); chOccLines = null; }
      return;
    }

    const labels = occSeries.months;
    const datasets = occSeries.houses.map(h=>{
      const data = occSeries.pctByHouse.get(h) || labels.map(()=>0);
      return { label:h, data, tension:0.25, pointRadius:0, borderWidth:1 };
    });

    if(chOccLines) chOccLines.destroy();
    chOccLines = new Chart(canvas, {
      type: "line",
      data: { labels, datasets },
      options: {
        responsive:true,
        maintainAspectRatio:false,
        interaction:{ mode:"nearest", intersect:false },
        plugins:{
          legend:{ display:true, position:"bottom", labels:{ boxWidth:10 } },
          tooltip:{ callbacks:{ label:(ctx)=>` ${ctx.dataset.label}: ${ctx.raw}%` } }
        },
        scales:{
          y:{ beginAtZero:true, max:100, ticks:{ callback:(v)=>`${v}%` } }
        }
      }
    });
  }

  function syncOccView(){
    const view = $("occView")?.value || "table";
    const lineWrap = $("occLineWrap");
    const tableWrap = $("occTableWrap");
    if(!lineWrap || !tableWrap) return;

    if(view === "line"){
      lineWrap.style.display = "";
      tableWrap.style.display = "none";
    }else{
      lineWrap.style.display = "none";
      tableWrap.style.display = "";
    }
  }

  function downloadCSV(){
    const url = `${API_BASE}/api/otc.csv?${qs()}`;
    window.location.href = url;
  }

  function setDefaultDates(){
    // ✅ 1 de enero de 2025 → hoy
    const today = new Date();
    const pad = (x)=>String(x).padStart(2,"0");
    const ymdLocal = (d)=>`${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;

    const d1 = new Date(2025, 0, 1); // local
    $("from").value = ymdLocal(d1);
    $("to").value = ymdLocal(today);
  }

  (function init(){
    $("baseUrl").textContent = API_BASE || "same-origin";
    setDefaultDates();

    // init multi-comboboxes
    initMCB("mcbPropiedad", { emptyLabel:"Todas", onChange: ()=> applyLocalFilters() });
    initMCB("mcbOccPropiedad", { emptyLabel:"Todas", onChange: ()=> renderOccupancyByMonth() });
    initMCB("mcbOccAvgMonths", { emptyLabel:"Todos", onChange: ()=> renderOccupancyByMonth() });
    initMCB("mcbOccHouses", { emptyLabel:"Todos", onChange: ()=> renderOccupancyByMonth() });

    // botones header
    $("btnReload").addEventListener("click", async ()=>{
      try{ await fetchOTC(); }
      catch(e){ setStatus("err","Error"); alert(String(e.message || e)); }
    });
    $("btnCsv").addEventListener("click", downloadCSV);
    $("btnDebug").addEventListener("click", loadDebug);

    // filtros instantáneos: cuando cambias fechas, se hace fetch inmediato (porque cambia el universo)
    // debounce para no spamear el backend
    let tFetch = null;
    function scheduleFetch(){
      clearTimeout(tFetch);
      tFetch = setTimeout(()=>{
        fetchOTC().catch(e=>{ setStatus("err","Error"); alert(String(e.message || e)); });
      }, 250);
    }

    ["from","to"].forEach(id=>{
      $(id).addEventListener("change", scheduleFetch);
      $(id).addEventListener("input", scheduleFetch);
    });

    // filtros locales (no requieren fetch)
    ["q","selSource","selStatus"].forEach(id=>{
      $(id).addEventListener("input", applyLocalFilters);
      $(id).addEventListener("change", applyLocalFilters);
    });


    // resumen por huésped: combobox
    const gc = $("guestCombo");
    if(gc){
      const onGuestChange = ()=>{
        // Si el usuario está escribiendo, el motor fuzzy define el mejor match
        renderGuestSummary();
        renderTable(); // para que cualquier icono/estilo dependiente se sincronice
      };
      gc.addEventListener("input", onGuestChange);
      gc.addEventListener("change", onGuestChange);
    }

    // vista ocupación
    $("occView").addEventListener("change", syncOccView);

    // ✅ carga inicial automática (ya no necesitas "Cargar")
    fetchOTC().catch(e=>{
      setStatus("err","Error");
      alert(String(e.message || e));
    });
  })();
</script>

<!-- ===================== -->
<!-- Resumen por huésped -->
<!-- ===================== -->
<section class="card" id="guestSummarySection">
  <h3>Resumen por huésped</h3>
  <label>Selecciona huésped</label>
  <input list="guestList" id="guestSelect" placeholder="Nombre o teléfono" />
  <datalist id="guestList"></datalist>

  <div class="kpis">
    <span id="gs_reservas">Reservas: –</span> |
    <span id="gs_monto">Monto: –</span> |
    <span id="gs_props">Alojamientos: –</span> |
    <span id="gs_score">Clasificación: –</span>
  </div>

  <table class="table">
    <thead><tr><th>Source</th><th>Reservas</th><th>Monto</th></tr></thead>
    <tbody id="gs_source_rows"></tbody>
  </table>
</section>

<script>
(function(){
  function norm(s){
    return (s||"").toString().normalize("NFD").replace(/\p{Diacritic}/gu,"").toLowerCase();
  }

  function buildGuests(rows){
    const m = {};
    rows.forEach(r=>{
      const name = r.GuestName || "";
      const phone = (r.GuestPhone||"").replace(/\D/g,"");
      const key = norm(name)+"|"+phone;
      if(!m[key]) m[key]={name,phone,rows:[]};
      m[key].rows.push(r);
    });
    return Object.values(m);
  }

  function scoreGuest(g){
    const reservas = new Set(g.rows.map(r=>r.Id)).size;
    const monto = g.rows.reduce((a,r)=>a+(+r.GrossAmount||0),0);
    const months = new Set(g.rows.map(r=>(r.CheckIn||"").slice(0,7))).size;
    const score = Math.min(40,reservas*8)+Math.min(40,Math.log10(monto+1)*10)+Math.min(20,months*5);
    return Math.round(score);
  }

  window.initGuestSummary = function(rows){
    const guests = buildGuests(rows);
    const dl = document.getElementById("guestList");
    dl.innerHTML = guests.map(g=>`<option value="${g.name} ${g.phone}">`).join("");

    const sel = document.getElementById("guestSelect");
    sel.oninput = ()=>{
      const v = norm(sel.value);
      const g = guests.find(x=>norm(x.name+" "+x.phone).includes(v));
      if(!g) return;
      const reservas = new Set(g.rows.map(r=>r.Id)).size;
      const monto = g.rows.reduce((a,r)=>a+(+r.GrossAmount||0),0);
      const props = new Set(g.rows.map(r=>r.HouseName)).size;
      const score = scoreGuest(g);
      const stars = "★★★★★☆☆☆☆☆".slice(5-Math.min(5,Math.ceil(score/20)),10);

      document.getElementById("gs_reservas").textContent = "Reservas: "+reservas;
      document.getElementById("gs_monto").textContent = "Monto: $"+monto.toFixed(0);
      document.getElementById("gs_props").textContent = "Alojamientos: "+props;
      document.getElementById("gs_score").textContent = "Clasificación: "+stars;

      const bySrc={};
      g.rows.forEach(r=>{
        bySrc[r.Source]=bySrc[r.Source]||{c:0,m:0};
        bySrc[r.Source].c++; bySrc[r.Source].m+=(+r.GrossAmount||0);
      });
      document.getElementById("gs_source_rows").innerHTML =
        Object.entries(bySrc).map(([s,o])=>`<tr><td>${s}</td><td>${o.c}</td><td>$${o.m.toFixed(0)}</td></tr>`).join("");
    };
  };
})();
</script>

</body>
</html>
